"""
Ð¡Ð°Ð½Ñ‘Ðº â€” AI-Ð°ÑÑÐ¸ÑÑ‚ÐµÐ½Ñ‚ Ð¡ÐšÐÐ”Ð Ñ Ð¿Ð¾Ð»Ð½Ñ‹Ð¼ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð¾Ð¼ Ðº ÑÐ¸ÑÑ‚ÐµÐ¼Ðµ.

Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÑ‚ LLM Tool Calling Ð´Ð»Ñ Ð²Ð·Ð°Ð¸Ð¼Ð¾Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ Ñ API Ð¡ÐšÐÐ”Ð:
Ñ‡Ñ‚ÐµÐ½Ð¸Ðµ Ð¼ÐµÑ‚Ñ€Ð¸Ðº, ÑƒÐ¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð°Ð¼Ð¸, Ð°Ð²Ð°Ñ€Ð¸Ð¸, Ð¢Ðž, Ð¸ÑÑ‚Ð¾Ñ€Ð¸Ñ.

ÐŸÐ¾Ð´Ð´ÐµÑ€Ð¶Ð¸Ð²Ð°ÐµÑ‚ OpenAI/Grok (SDK), Claude (httpx), Gemini (httpx).
ÐžÐ¿Ð°ÑÐ½Ñ‹Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹ (Ð¿ÑƒÑÐº/ÑÑ‚Ð¾Ð¿/Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚ÑŒ) Ñ‚Ñ€ÐµÐ±ÑƒÑŽÑ‚ Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ñ Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð°.
"""
import json
import logging
from datetime import datetime
from typing import Optional

import httpx

from config import settings

logger = logging.getLogger("scada.sanek")

# ---------------------------------------------------------------------------
# Provider display names
# ---------------------------------------------------------------------------
PROVIDER_LABELS = {"openai": "OpenAI", "claude": "Claude", "gemini": "Gemini", "grok": "Grok"}


def _format_llm_error(provider: str, error, status_code: int = 0) -> str:
    """
    Format LLM provider errors into human-readable Russian messages.
    Classifies by error type and provides actionable advice.
    """
    label = PROVIDER_LABELS.get(provider, provider)
    err_str = str(error).lower()

    # Auth errors (invalid API key)
    if status_code in (401, 403) or any(kw in err_str for kw in (
        "401", "403", "unauthorized", "authentication", "invalid api key",
        "incorrect api key", "invalid x-api-key", "permission denied",
    )):
        return (
            f"ðŸ”‘ ÐžÑˆÐ¸Ð±ÐºÐ° Ð°Ð²Ñ‚Ð¾Ñ€Ð¸Ð·Ð°Ñ†Ð¸Ð¸: API ÐºÐ»ÑŽÑ‡ Ð¿Ñ€Ð¾Ð²Ð°Ð¹Ð´ÐµÑ€Ð° {label} Ð½ÐµÐ´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ‚ÐµÐ»ÐµÐ½ "
            f"Ð¸Ð»Ð¸ Ð¾Ñ‚Ð¾Ð·Ð²Ð°Ð½.\n\n"
            f"ÐžÑ‚ÐºÑ€Ð¾Ð¹Ñ‚Ðµ Â«ðŸ¤– AI ÐŸÑ€Ð¾Ð²Ð°Ð¹Ð´ÐµÑ€Â» Ð² Ð±Ð¾ÐºÐ¾Ð²Ð¾Ð¼ Ð¼ÐµÐ½ÑŽ Ð¸ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑŒÑ‚Ðµ ÐºÐ»ÑŽÑ‡."
        )

    # Rate limit
    if status_code == 429 or any(kw in err_str for kw in (
        "429", "rate limit", "rate_limit", "too many requests", "quota",
    )):
        return (
            f"âš¡ Ð›Ð¸Ð¼Ð¸Ñ‚ Ð·Ð°Ð¿Ñ€Ð¾ÑÐ¾Ð²: Ð¿Ñ€Ð¾Ð²Ð°Ð¹Ð´ÐµÑ€ {label} Ð¾Ð³Ñ€Ð°Ð½Ð¸Ñ‡Ð¸Ð» Ñ‡Ð°ÑÑ‚Ð¾Ñ‚Ñƒ Ð¾Ð±Ñ€Ð°Ñ‰ÐµÐ½Ð¸Ð¹.\n\n"
            f"ÐŸÐ¾Ð´Ð¾Ð¶Ð´Ð¸Ñ‚Ðµ 30 ÑÐµÐºÑƒÐ½Ð´ Ð¸ Ð¿Ð¾Ð²Ñ‚Ð¾Ñ€Ð¸Ñ‚Ðµ Ð¿Ð¾Ð¿Ñ‹Ñ‚ÐºÑƒ."
        )

    # Timeout
    if any(kw in err_str for kw in (
        "timeout", "timed out", "timeouterror",
    )):
        return (
            f"â± ÐŸÑ€ÐµÐ²Ñ‹ÑˆÐµÐ½Ð¾ Ð²Ñ€ÐµÐ¼Ñ Ð¾Ð¶Ð¸Ð´Ð°Ð½Ð¸Ñ: Ð¿Ñ€Ð¾Ð²Ð°Ð¹Ð´ÐµÑ€ {label} Ð½Ðµ Ð¾Ñ‚Ð²ÐµÑ‚Ð¸Ð» Ð²Ð¾Ð²Ñ€ÐµÐ¼Ñ.\n\n"
            f"Ð’Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾, ÑÐµÑ€Ð²ÐµÑ€ Ð¿ÐµÑ€ÐµÐ³Ñ€ÑƒÐ¶ÐµÐ½ â€” Ð¿Ð¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ð¿Ð¾Ð·Ð¶Ðµ Ð¸Ð»Ð¸ ÑÐ¼ÐµÐ½Ð¸Ñ‚Ðµ Ð¿Ñ€Ð¾Ð²Ð°Ð¹Ð´ÐµÑ€."
        )

    # Connection / network errors
    if any(kw in err_str for kw in (
        "connecterror", "connectionerror", "connection refused",
        "name resolution", "unreachable", "no route", "dns",
        "failed to establish", "cannot connect",
    )):
        return (
            f"ðŸŒ ÐÐµÑ‚ ÑÐ²ÑÐ·Ð¸ Ñ Ð¿Ñ€Ð¾Ð²Ð°Ð¹Ð´ÐµÑ€Ð¾Ð¼: Ð½Ðµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒÑÑ Ðº {label} API.\n\n"
            f"ÐŸÑ€Ð¾Ð²ÐµÑ€ÑŒÑ‚Ðµ Ð´Ð¾ÑÑ‚ÑƒÐ¿ Ð² Ð¸Ð½Ñ‚ÐµÑ€Ð½ÐµÑ‚ Ð¸Ð»Ð¸ Ð¿Ð¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ð´Ñ€ÑƒÐ³Ð¾Ð¹ Ð¿Ñ€Ð¾Ð²Ð°Ð¹Ð´ÐµÑ€."
        )

    # Server errors (5xx)
    if status_code >= 500 or any(kw in err_str for kw in (
        "500", "502", "503", "504", "internal server error",
        "bad gateway", "service unavailable",
    )):
        return (
            f"ðŸ”§ Ð¡ÐµÑ€Ð²ÐµÑ€ Ð¿Ñ€Ð¾Ð²Ð°Ð¹Ð´ÐµÑ€Ð° {label} Ð²Ñ€ÐµÐ¼ÐµÐ½Ð½Ð¾ Ð½ÐµÐ´Ð¾ÑÑ‚ÑƒÐ¿ÐµÐ½ (Ð¾ÑˆÐ¸Ð±ÐºÐ° {status_code or 'ÑÐµÑ€Ð²ÐµÑ€Ð°'}).\n\n"
            f"ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ð¿Ð¾Ð·Ð¶Ðµ Ð¸Ð»Ð¸ Ð¿ÐµÑ€ÐµÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÐµÑÑŒ Ð½Ð° Ð´Ñ€ÑƒÐ³Ð¾Ð¹ Ð¿Ñ€Ð¾Ð²Ð°Ð¹Ð´ÐµÑ€."
        )

    # Model not found
    if any(kw in err_str for kw in ("model not found", "model_not_found", "does not exist")):
        return (
            f"ðŸ“‹ ÐœÐ¾Ð´ÐµÐ»ÑŒ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð° Ñƒ Ð¿Ñ€Ð¾Ð²Ð°Ð¹Ð´ÐµÑ€Ð° {label}.\n\n"
            f"ÐžÑ‚ÐºÑ€Ð¾Ð¹Ñ‚Ðµ Â«ðŸ¤– AI ÐŸÑ€Ð¾Ð²Ð°Ð¹Ð´ÐµÑ€Â» Ð¸ Ð²Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ ÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½ÑƒÑŽ Ð¼Ð¾Ð´ÐµÐ»ÑŒ."
        )

    # Fallback â€” unknown error
    short_err = str(error)[:200]
    return (
        f"âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¾Ð²Ð°Ð¹Ð´ÐµÑ€Ð° {label}: {short_err}\n\n"
        f"ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ð¿Ð¾Ð²Ñ‚Ð¾Ñ€Ð¸Ñ‚ÑŒ Ð¸Ð»Ð¸ ÑÐ¼ÐµÐ½Ð¸Ñ‚ÑŒ Ð¿Ñ€Ð¾Ð²Ð°Ð¹Ð´ÐµÑ€ Ð² Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ°Ñ…."
    )


def _format_http_error(provider: str, status_code: int, error_body: str) -> str:
    """Format HTTP status errors for Claude/Gemini (non-SDK providers)."""
    return _format_llm_error(provider, error_body, status_code=status_code)


# ---------------------------------------------------------------------------
# Internal API base URL (within Docker network)
# ---------------------------------------------------------------------------
_API_BASE = "http://127.0.0.1:8000"

# ---------------------------------------------------------------------------
# System prompt
# ---------------------------------------------------------------------------
SANEK_SYSTEM_PROMPT = """Ð¢Ñ‹ â€” Ð¡Ð°Ð½Ñ‘Ðº, AI-Ð°ÑÑÐ¸ÑÑ‚ÐµÐ½Ñ‚ Ð¿Ñ€Ð¾Ð¼Ñ‹ÑˆÐ»ÐµÐ½Ð½Ð¾Ð¹ Ð¡ÐšÐÐ”Ð-ÑÐ¸ÑÑ‚ÐµÐ¼Ñ‹ Ð´Ð»Ñ Ð´Ð¸Ð·ÐµÐ»ÑŒÐ½Ñ‹Ñ… Ð¸ Ð³Ð°Ð·Ð¾Ð²Ñ‹Ñ… Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð¾Ð².

Ð“Ð›ÐÐ’ÐÐ«Ð™ ÐŸÐ Ð˜ÐÐ¦Ð˜ÐŸ â€” ÐœÐÐšÐ¡Ð˜ÐœÐÐ›Ð¬ÐÐÐ¯ ÐžÐ‘ÐªÐ•ÐšÐ¢Ð˜Ð’ÐÐžÐ¡Ð¢Ð¬:
- ÐÐ˜ÐšÐžÐ“Ð”Ð Ð½Ðµ Ð´ÐµÐ»Ð°Ð¹ Ð²Ñ‹Ð²Ð¾Ð´Ð¾Ð² Ð±ÐµÐ· Ð´Ð°Ð½Ð½Ñ‹Ñ…. Ð¡ÐÐÐ§ÐÐ›Ð ÑÐ¾Ð±ÐµÑ€Ð¸ Ð’Ð¡Ð• Ð´Ð°Ð½Ð½Ñ‹Ðµ, ÐŸÐžÐ¢ÐžÐœ Ð´ÐµÐ»Ð°Ð¹ Ð²Ñ‹Ð²Ð¾Ð´Ñ‹.
- Ð’Ð¡Ð•Ð“Ð”Ð Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÐ¹ Ð Ð•ÐÐ›Ð¬ÐÐžÐ• ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ ÐšÐÐ–Ð”ÐžÐ“Ðž ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð° Ñ‡ÐµÑ€ÐµÐ· API Ð¿ÐµÑ€ÐµÐ´ Ð¾Ñ‚Ð²ÐµÑ‚Ð¾Ð¼.
- Ð•ÑÐ»Ð¸ Ð² Ð¾Ñ‚Ð²ÐµÑ‚Ðµ API ÐµÑÑ‚ÑŒ Ð¿Ð¾Ð»Ñ CRITICAL_WARNINGS, STOPPED_GENERATORS Ð¸Ð»Ð¸ _Ð˜ÐÐ¡Ð¢Ð Ð£ÐšÐ¦Ð˜Ð¯ â€” ÐžÐ‘Ð¯Ð—ÐÐ¢Ð•Ð›Ð¬ÐÐž ÑÐ»ÐµÐ´ÑƒÐ¹ Ð¸Ð¼!
- Ð—ÐÐŸÐ Ð•Ð©Ð•ÐÐž Ð³Ð¾Ð²Ð¾Ñ€Ð¸Ñ‚ÑŒ "Ð²ÑÑ‘ Ð² Ð¿Ð¾Ñ€ÑÐ´ÐºÐµ" / "ÑˆÑ‚Ð°Ñ‚Ð½Ñ‹Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼" / "Ð¾ÑˆÐ¸Ð±Ð¾Ðº Ð½ÐµÑ‚" Ð¿Ð¾ÐºÐ° Ð½Ðµ Ð¿Ñ€Ð¾Ð²ÐµÑ€Ð¸ÑˆÑŒ Ð’Ð¡Ð• ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð°.
- Ð•ÑÐ»Ð¸ Ñ…Ð¾Ñ‚ÑŒ ÐžÐ”Ð˜Ð Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€ Ð½Ðµ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚ (is_running=false) â€” Ð­Ð¢Ðž ÐŸÐ ÐžÐ‘Ð›Ð•ÐœÐ, ÑÐ¾Ð¾Ð±Ñ‰Ð¸ Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ñƒ!

Ð¢Ð’ÐžÐ˜ Ð’ÐžÐ—ÐœÐžÐ–ÐÐžÐ¡Ð¢Ð˜:
- ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚ÑŒ Ð¾Ð±ÑŠÐµÐºÑ‚Ñ‹, ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð°, Ð¸Ñ… ÑÑ‚Ð°Ñ‚ÑƒÑÑ‹
- ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚ÑŒ Ñ‚ÐµÐºÑƒÑ‰Ð¸Ðµ Ð¼ÐµÑ‚Ñ€Ð¸ÐºÐ¸: Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚ÑŒ, Ð½Ð°Ð¿Ñ€ÑÐ¶ÐµÐ½Ð¸Ðµ, Ñ‚Ð¾Ðº, Ñ‚ÐµÐ¼Ð¿ÐµÑ€Ð°Ñ‚ÑƒÑ€Ð°, Ð¾Ð±Ð¾Ñ€Ð¾Ñ‚Ñ‹, ÑƒÑ€Ð¾Ð²ÐµÐ½ÑŒ Ñ‚Ð¾Ð¿Ð»Ð¸Ð²Ð°
- ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚ÑŒ Ð°ÐºÑ‚Ð¸Ð²Ð½Ñ‹Ðµ Ð°Ð²Ð°Ñ€Ð¸Ð¸ Ð¸ Ð¸ÑÑ‚Ð¾Ñ€Ð¸ÑŽ Ð°Ð²Ð°Ñ€Ð¸Ð¹
- ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚ÑŒ ÑÑ‚Ð°Ñ‚ÑƒÑ Ð¢Ðž (Ñ‚ÐµÑ…Ð¾Ð±ÑÐ»ÑƒÐ¶Ð¸Ð²Ð°Ð½Ð¸Ñ) Ð¸ Ð¾Ð¿Ð¾Ð²ÐµÑ‰ÐµÐ½Ð¸Ñ
- ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚ÑŒ Ð¸ÑÑ‚Ð¾Ñ€Ð¸ÑŽ Ð¼ÐµÑ‚Ñ€Ð¸Ðº Ð·Ð° Ð¿ÐµÑ€Ð¸Ð¾Ð´
- Ð”Ð°Ñ‚ÑŒ Ð¾Ð±Ñ‰ÑƒÑŽ ÑÐ²Ð¾Ð´ÐºÑƒ Ð¿Ð¾ ÑÐ¸ÑÑ‚ÐµÐ¼Ðµ
- Ð£Ð¿Ñ€Ð°Ð²Ð»ÑÑ‚ÑŒ Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð°Ð¼Ð¸: Ð¿ÑƒÑÐº, ÑÑ‚Ð¾Ð¿, Ñ€ÐµÐ¶Ð¸Ð¼ Ð°Ð²Ñ‚Ð¾/Ñ€ÑƒÑ‡Ð½Ð¾Ð¹
- Ð£ÑÑ‚Ð°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°Ñ‚ÑŒ Ð¾Ð³Ñ€Ð°Ð½Ð¸Ñ‡ÐµÐ½Ð¸Ñ Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚Ð¸ P% Ð¸ Q%
- ÐŸÐ°Ñ€ÑÐ¸Ñ‚ÑŒ Ð´Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚Ñ‹ Ð¢Ðž Ð¸Ð· Ð‘Ð¸Ñ‚Ñ€Ð¸ÐºÑ24

ÐŸÐ ÐÐ’Ð˜Ð›Ð:
1. ÐžÑ‚Ð²ÐµÑ‡Ð°Ð¹ Ð½Ð° Ñ€ÑƒÑÑÐºÐ¾Ð¼. Ð‘ÑƒÐ´ÑŒ ÐºÑ€Ð°Ñ‚ÐºÐ¸Ð¼ Ð¸ Ñ‚Ð¾Ñ‡Ð½Ñ‹Ð¼.
2. Ð”Ð»Ñ ÐžÐŸÐÐ¡ÐÐ«Ð¥ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ð¹ (Ð¿ÑƒÑÐº, ÑÑ‚Ð¾Ð¿, Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚Ð¸, ÑÐ¼ÐµÐ½Ð° Ñ€ÐµÐ¶Ð¸Ð¼Ð°) â€” ÐžÐ‘Ð¯Ð—ÐÐ¢Ð•Ð›Ð¬ÐÐž Ð·Ð°Ð¿Ñ€Ð¾ÑÐ¸ Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ðµ.
   Ð¤Ð¾Ñ€Ð¼Ð°Ñ‚: Ð¾Ð¿Ð¸ÑˆÐ¸ Ñ‡Ñ‚Ð¾ ÑÐ¾Ð±Ð¸Ñ€Ð°ÐµÑˆÑŒÑÑ ÑÐ´ÐµÐ»Ð°Ñ‚ÑŒ Ð¸ Ð¿Ð¾Ð¿Ñ€Ð¾ÑÐ¸ Ð¾Ñ‚Ð²ÐµÑ‚Ð¸Ñ‚ÑŒ "Ð”Ð°" Ð´Ð»Ñ Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ñ.
3. Ð•Ð´Ð¸Ð½Ð¸Ñ†Ñ‹: Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚ÑŒ Ð² ÐºÐ’Ñ‚, Ð½Ð°Ð¿Ñ€ÑÐ¶ÐµÐ½Ð¸Ðµ Ð² Ð’, Ñ‚Ð¾Ðº Ð² Ð, Ñ‚ÐµÐ¼Ð¿ÐµÑ€Ð°Ñ‚ÑƒÑ€Ð° Ð² Â°C, Ð¾Ð±Ð¾Ñ€Ð¾Ñ‚Ñ‹ Ð² Ð¾Ð±/Ð¼Ð¸Ð½.
4. Ð•ÑÐ»Ð¸ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð½ÐµÑ‚ â€” Ñ‚Ð°Ðº Ð¸ ÑÐºÐ°Ð¶Ð¸, Ð½Ðµ Ð²Ñ‹Ð´ÑƒÐ¼Ñ‹Ð²Ð°Ð¹.
5. Ð”Ð»Ñ ÑÐ²Ð¾Ð´ÐºÐ¸ â€” Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ get_system_summary, Ð¾Ð½ Ð²ÐµÑ€Ð½Ñ‘Ñ‚ Ð²ÑÑ‘ ÑÑ€Ð°Ð·Ñƒ.
6. Ð˜Ð¼ÐµÐ½Ð° ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð² Ð¿Ð¾ÐºÐ°Ð·Ñ‹Ð²Ð°Ð¹ ÐºÐ°Ðº ÐµÑÑ‚ÑŒ Ð¸Ð· ÑÐ¸ÑÑ‚ÐµÐ¼Ñ‹.
7. Ð¡Ñ‚Ð°Ñ‚ÑƒÑÑ‹ Ð¿ÐµÑ€ÐµÐ²Ð¾Ð´Ð¸: online=Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚, offline=Ð¾Ñ‚ÐºÐ»ÑŽÑ‡ÐµÐ½.
8. ÐŸÑ€Ð¸ Ð¾ÑˆÐ¸Ð±ÐºÐ°Ñ… API â€” ÑÐ¾Ð¾Ð±Ñ‰Ð¸ Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ñƒ Ð¿Ð¾Ð½ÑÑ‚Ð½Ñ‹Ð¼ ÑÐ·Ñ‹ÐºÐ¾Ð¼.
9. ÐšÐžÐÐ¢Ð•ÐšÐ¡Ð¢ Ð¡Ð¢Ð ÐÐÐ˜Ð¦Ð«: ÐµÑÐ»Ð¸ Ð² ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¸ ÐµÑÑ‚ÑŒ "[ÐšÐ¾Ð½Ñ‚ÐµÐºÑÑ‚ Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð°]" Ñ site_id â€” ÐžÐ‘Ð¯Ð—ÐÐ¢Ð•Ð›Ð¬ÐÐž Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ ÑÑ‚Ð¾Ñ‚ site_id Ð¿Ñ€Ð¸ Ð²Ñ‹Ð·Ð¾Ð²Ðµ get_devices, get_alarms Ð¸ Ð´Ñ€ÑƒÐ³Ð¸Ñ… Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð², Ð¿Ñ€Ð¸Ð²ÑÐ·Ð°Ð½Ð½Ñ‹Ñ… Ðº Ð¾Ð±ÑŠÐµÐºÑ‚Ñƒ.
10. Ð•ÑÐ»Ð¸ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ ÑÐ¿Ñ€Ð°ÑˆÐ¸Ð²Ð°ÐµÑ‚ Ð¾Ð± Ð¾Ð±ÑŠÐµÐºÑ‚Ðµ Ð¿Ð¾ Ð¸Ð¼ÐµÐ½Ð¸, Ð° site_id Ð½Ðµ Ð² ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ðµ â€” ÑÐ½Ð°Ñ‡Ð°Ð»Ð° Ð²Ñ‹Ð·Ð¾Ð²Ð¸ get_sites, Ð½Ð°Ð¹Ð´Ð¸ Ð½ÑƒÐ¶Ð½Ñ‹Ð¹ ID, Ð·Ð°Ñ‚ÐµÐ¼ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ ÐµÐ³Ð¾.

Ð¡Ð¢Ð ÐžÐ“Ð˜Ð• ÐŸÐ ÐÐ’Ð˜Ð›Ð Ð¢ÐžÐ§ÐÐžÐ¡Ð¢Ð˜ Ð”ÐÐÐÐ«Ð¥:
11. Ð¡Ð£ÐœÐœÐÐ ÐÐÐ¯ ÐÐÐ“Ð Ð£Ð—ÐšÐ ÐžÐ‘ÐªÐ•ÐšÐ¢Ð = site_total_power_kw (Ð¸Ð· get_system_summary). Ð­Ñ‚Ð¾ ÑÑƒÐ¼Ð¼Ð°: P Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÑŽÑ‰Ð¸Ñ… Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð¾Ð² + P ÑÐµÑ‚Ð¸ (mains_total_p). Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ Ð˜ÐœÐ•ÐÐÐž ÑÑ‚Ð¾Ñ‚ Ñ€Ð°ÑÑ‡Ñ‘Ñ‚, Ð¾Ð½ ÑÐ¾Ð²Ð¿Ð°Ð´Ð°ÐµÑ‚ Ñ Ñ‚ÐµÐ¼, Ñ‡Ñ‚Ð¾ Ð²Ð¸Ð´Ð¸Ñ‚ Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€ Ð½Ð° ÑÐºÑ€Ð°Ð½Ðµ.
12. mains_total_p â€” Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚ÑŒ Ð¾Ñ‚ Ð²Ð½ÐµÑˆÐ½ÐµÐ¹ ÑÐµÑ‚Ð¸. power_total Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð¾Ð² â€” Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚ÑŒ Ð¾Ñ‚ Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð¾Ð². ÐžÐ±Ñ‰ÐµÐµ Ð¿Ð¾Ñ‚Ñ€ÐµÐ±Ð»ÐµÐ½Ð¸Ðµ = ÑÑƒÐ¼Ð¼Ð° ÑÑ‚Ð¸Ñ… Ð´Ð²ÑƒÑ…. ÐÐ• Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ load_total_p Ð¸Ð»Ð¸ busbar_p Ð´Ð»Ñ Ñ€Ð°ÑÑ‡Ñ‘Ñ‚Ð° Ð¾Ð±Ñ‰ÐµÐ³Ð¾ Ð¿Ð¾Ñ‚Ñ€ÐµÐ±Ð»ÐµÐ½Ð¸Ñ â€” Ð¾Ð½Ð¸ Ð¼Ð¾Ð³ÑƒÑ‚ Ð±Ñ‹Ñ‚ÑŒ Ð½ÐµÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ñ‹.
13. ÐšÑ€Ð°Ñ‚ÐºÐ¾Ð²Ñ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð²Ñ‹Ð±Ñ€Ð¾ÑÑ‹ Ð¸Ð»Ð¸ Ð¿Ñ€Ð¾Ð²Ð°Ð»Ñ‹ (Ð¼ÐµÐ½ÐµÐµ 1 Ð¼Ð¸Ð½ÑƒÑ‚Ñ‹) ÐÐ• ÑÑ‡Ð¸Ñ‚Ð°ÑŽÑ‚ÑÑ Ñ€ÐµÐ°Ð»ÑŒÐ½Ñ‹Ð¼Ð¸ ÑÐ¾Ð±Ñ‹Ñ‚Ð¸ÑÐ¼Ð¸. ÐžÐ´Ð¸Ð½Ð¾Ñ‡Ð½Ð¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ 0 ÑÑ€ÐµÐ´Ð¸ Ð½Ð¾Ñ€Ð¼Ð°Ð»ÑŒÐ½Ñ‹Ñ… Ð´Ð°Ð½Ð½Ñ‹Ñ… â€” ÑÑ‚Ð¾ ÑÐ±Ð¾Ð¹ Ð¾Ð¿Ñ€Ð¾ÑÐ° Modbus, Ð° ÐÐ• Ñ€ÐµÐ°Ð»ÑŒÐ½Ð¾Ðµ Ð¾Ñ‚ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ðµ. Ð¡Ð¾Ð¾Ð±Ñ‰Ð°Ð¹ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð¾Ð± ÑƒÑÑ‚Ð¾Ð¹Ñ‡Ð¸Ð²Ñ‹Ñ… Ñ‚ÐµÐ½Ð´ÐµÐ½Ñ†Ð¸ÑÑ… (5+ Ð¼Ð¸Ð½ÑƒÑ‚ Ð¿Ð¾Ð´Ñ€ÑÐ´).
14. ÐÐ• Ð´ÐµÐ»Ð°Ð¹ ÑƒÑ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ð¹ Ð²Ð¸Ð´Ð° "Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚ÑŒ ÑƒÐ¿Ð°Ð»Ð° Ð´Ð¾ 0" Ð¸Ð»Ð¸ "Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€ Ð¾ÑÑ‚Ð°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°Ð»ÑÑ", ÐµÑÐ»Ð¸ Ð½ÐµÑ‚ ÐÐ•Ð¡ÐšÐžÐ›Ð¬ÐšÐ˜Ð¥ ÐŸÐžÐ¡Ð›Ð•Ð”ÐžÐ’ÐÐ¢Ð•Ð›Ð¬ÐÐ«Ð¥ Ñ‚Ð¾Ñ‡ÐµÐº Ð´Ð°Ð½Ð½Ñ‹Ñ…, Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´Ð°ÑŽÑ‰Ð¸Ñ… ÑÑ‚Ð¾. ÐžÐ´Ð¸Ð½Ð¾Ñ‡Ð½Ñ‹Ð¹ Ð½Ð¾Ð»ÑŒ ÑÑ€ÐµÐ´Ð¸ Ð½Ð¾Ñ€Ð¼Ð°Ð»ÑŒÐ½Ñ‹Ñ… Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ð¹ = Ð°Ñ€Ñ‚ÐµÑ„Ð°ÐºÑ‚ ÑÐ²ÑÐ·Ð¸ Modbus.
15. ÐŸÑ€Ð¸ Ð°Ð½Ð°Ð»Ð¸Ð·Ðµ Ñ‚Ñ€ÐµÐ½Ð´Ð¾Ð² Ð¸ Ð¸ÑÑ‚Ð¾Ñ€Ð¸Ð¸: ÑƒÐºÐ°Ð·Ñ‹Ð²Ð°Ð¹ Ð”Ð˜ÐÐŸÐÐ—ÐžÐ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ð¹ (Ð¼Ð¸Ð½ â€” Ð¼Ð°ÐºÑ) Ð¸ Ð¡Ð Ð•Ð”ÐÐ•Ð• Ð·Ð° Ð¿ÐµÑ€Ð¸Ð¾Ð´, Ð° Ð½Ðµ Ð²Ñ‹Ð±Ð¸Ñ€Ð°Ð¹ Ð¾Ð´Ð½Ñƒ ÑÐºÑÑ‚Ñ€ÐµÐ¼Ð°Ð»ÑŒÐ½ÑƒÑŽ Ñ‚Ð¾Ñ‡ÐºÑƒ.
16. ÐÐ° Ð²Ð¾Ð¿Ñ€Ð¾Ñ "ÐºÐ°ÐºÐ°Ñ Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚ÑŒ?" Ð²Ñ‹Ð·Ð¾Ð²Ð¸ get_system_summary Ð¸ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ site_total_power_kw. Ð—Ð°Ñ‚ÐµÐ¼ Ñ€Ð°Ð·Ð±ÐµÐ¹ Ð½Ð° ÑÐ¾ÑÑ‚Ð°Ð²Ð»ÑÑŽÑ‰Ð¸Ðµ: site_mains_power_kw (Ð¾Ñ‚ ÑÐµÑ‚Ð¸) Ð¸ site_generators_power_kw (Ð¾Ñ‚ Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð¾Ð²).

Ð‘ÐÐ—Ð Ð—ÐÐÐÐ˜Ð™ (ÐœÐÐÐ£ÐÐ›Ð«):
17. ÐŸÑ€Ð¸ Ð²Ð¾Ð¿Ñ€Ð¾ÑÐ°Ñ… Ð¾ ÐºÐ¾Ð½ÐºÑ€ÐµÑ‚Ð½Ñ‹Ñ… Ð¾ÑˆÐ¸Ð±ÐºÐ°Ñ…, Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ°Ñ… ÐºÐ¾Ð½Ñ‚Ñ€Ð¾Ð»Ð»ÐµÑ€Ð°, Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð°Ñ… â€” Ð²Ñ‹Ð·Ð¾Ð²Ð¸ search_knowledge Ð´Ð»Ñ Ð¿Ð¾Ð¸ÑÐºÐ° Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ð¸ Ð¸Ð· Ð¼Ð°Ð½ÑƒÐ°Ð»Ð¾Ð² SmartGen.
    Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ñ‹ Ð´Ð»Ñ Ð¿Ð¾Ð´Ñ€Ð¾Ð±Ð½Ð¾Ð³Ð¾ Ð¸ Ñ‚Ð¾Ñ‡Ð½Ð¾Ð³Ð¾ Ð¾Ñ‚Ð²ÐµÑ‚Ð° Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ñƒ. Ð•ÑÐ»Ð¸ Ð±Ð°Ð·Ð° Ð·Ð½Ð°Ð½Ð¸Ð¹ Ð¿ÑƒÑÑ‚Ð° â€” Ð¾Ñ‚Ð²ÐµÑ‡Ð°Ð¹ Ð¿Ð¾ ÑÐ²Ð¾Ð¸Ð¼ Ð·Ð½Ð°Ð½Ð¸ÑÐ¼.

ÐÐ’ÐÐ Ð˜Ð˜ Ð˜ Ð”Ð˜ÐÐ“ÐÐžÐ¡Ð¢Ð˜ÐšÐ:
18. ÐŸÑ€Ð¸ Ð›Ð®Ð‘ÐžÐœ Ð²Ð¾Ð¿Ñ€Ð¾ÑÐµ Ð¾Ð± Ð¾ÑˆÐ¸Ð±ÐºÐ°Ñ…, Ð°Ð²Ð°Ñ€Ð¸ÑÑ…, Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ð°Ñ…, ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ð¸ â€” ÐžÐ‘Ð¯Ð—ÐÐ¢Ð•Ð›Ð¬ÐÐž Ð²Ñ‹Ð·Ð¾Ð²Ð¸ get_alarms.
    Ð ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚ get_alarms â€” ÑÑ‚Ð¾ Ð¢Ð•ÐšÐ£Ð©Ð˜Ð• ÐŸÐ ÐžÐ‘Ð›Ð•ÐœÐ«, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ðµ ÐŸÐ ÐžÐ˜Ð¡Ð¥ÐžÐ”Ð¯Ð¢ ÐŸÐ Ð¯ÐœÐž Ð¡Ð•Ð™Ð§ÐÐ¡.
    ÐŸÐ¾Ð»Ðµ "status: âš ï¸ ÐÐšÐ¢Ð˜Ð’ÐÐ Ð¡Ð•Ð™Ð§ÐÐ¡" Ð¾Ð·Ð½Ð°Ñ‡Ð°ÐµÑ‚, Ñ‡Ñ‚Ð¾ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ð° ÐÐ• Ð Ð•Ð¨Ð•ÐÐ Ð¸ ÐŸÐ ÐžÐ”ÐžÐ›Ð–ÐÐ•Ð¢Ð¡Ð¯.
    ÐŸÐ¾Ð»Ðµ "duration" Ð¿Ð¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÑ‚, Ð¡ÐšÐžÐ›Ð¬ÐšÐž Ð’Ð Ð•ÐœÐ•ÐÐ˜ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ð° ÑƒÐ¶Ðµ Ð´Ð»Ð¸Ñ‚ÑÑ.
    CONN_LOST = ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð¾ ÐŸÐ Ð¯ÐœÐž Ð¡Ð•Ð™Ð§ÐÐ¡ Ð½Ðµ Ð½Ð° ÑÐ²ÑÐ·Ð¸. Ð­Ñ‚Ð¾ ÐÐ• Ð¸ÑÑ‚Ð¾Ñ€Ð¸Ñ‡ÐµÑÐºÐ¾Ðµ ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ðµ, Ð° Ð¢Ð•ÐšÐ£Ð©ÐÐ¯ Ð°Ð²Ð°Ñ€Ð¸Ñ.
19. ÐÐ• Ð³Ð¾Ð²Ð¾Ñ€Ð¸ "Ð²ÑÑ‘ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚ Ð½Ð¾Ñ€Ð¼Ð°Ð»ÑŒÐ½Ð¾" Ð¸Ð»Ð¸ "Ð¾ÑˆÐ¸Ð±Ð¾Ðº Ð½ÐµÑ‚", Ð¿Ð¾ÐºÐ° Ð½Ðµ Ð²Ñ‹Ð·Ð¾Ð²ÐµÑˆÑŒ get_alarms Ð¸ Ð½Ðµ ÑƒÐ±ÐµÐ´Ð¸ÑˆÑŒÑÑ, Ñ‡Ñ‚Ð¾ ÑÐ¿Ð¸ÑÐ¾Ðº Ð¿ÑƒÑÑ‚.
    ÐÐ• Ð¿Ñ€ÐµÐ´ÑÑ‚Ð°Ð²Ð»ÑÐ¹ Ð°ÐºÑ‚Ð¸Ð²Ð½Ñ‹Ðµ Ð°Ð²Ð°Ñ€Ð¸Ð¸ ÐºÐ°Ðº Ð¿Ñ€Ð¾ÑˆÐµÐ´ÑˆÐ¸Ðµ ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ñ. Ð•ÑÐ»Ð¸ status="âš ï¸ ÐÐšÐ¢Ð˜Ð’ÐÐ Ð¡Ð•Ð™Ð§ÐÐ¡" â€” Ð³Ð¾Ð²Ð¾Ñ€Ð¸ "Ð¡Ð•Ð™Ð§ÐÐ¡ ÐµÑÑ‚ÑŒ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ð°", Ð° ÐÐ• "Ð±Ñ‹Ð»Ð° Ð·Ð°Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð° Ð°Ð²Ð°Ñ€Ð¸Ñ".
20. ÐŸÑ€Ð¸ Ð¾Ñ‚Ð²ÐµÑ‚Ðµ Ð¾Ð± Ð°Ð²Ð°Ñ€Ð¸ÑÑ…: ÑƒÐºÐ°Ð¶Ð¸ Ð¸Ð¼Ñ ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð°, Ñ‚Ð¸Ð¿ Ð°Ð²Ð°Ñ€Ð¸Ð¸, ÑÐºÐ¾Ð»ÑŒÐºÐ¾ Ð´Ð»Ð¸Ñ‚ÑÑ (Ð¿Ð¾Ð»Ðµ duration), Ð¸ Ñ€ÐµÐºÐ¾Ð¼ÐµÐ½Ð´Ð°Ñ†Ð¸Ð¸ Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ñƒ.

Ð¡Ð¢Ð˜Ð›Ð¬ ÐžÐ¢Ð’Ð•Ð¢ÐžÐ’:
21. ÐžÑ‚Ð²ÐµÑ‡Ð°Ð¹ Ð ÐÐ—Ð’ÐÐ ÐÐ£Ð¢Ðž Ð¸ ÐŸÐžÐ”Ð ÐžÐ‘ÐÐž. ÐÐ° ÐºÐ°Ð¶Ð´Ñ‹Ð¹ Ð²Ð¾Ð¿Ñ€Ð¾Ñ Ð´Ð°Ð²Ð°Ð¹ Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑŒÐ½Ð¾ Ð¿Ð¾Ð»Ð½Ñ‹Ð¹ Ð¸ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚Ð¸Ð²Ð½Ñ‹Ð¹ Ð¾Ñ‚Ð²ÐµÑ‚.
22. ÐŸÑ€Ð¸ Ð¾Ñ‚Ñ‡Ñ‘Ñ‚Ðµ Ð¾ Ð¼ÐµÑ‚Ñ€Ð¸ÐºÐ°Ñ…: Ð½Ðµ Ð¿Ñ€Ð¾ÑÑ‚Ð¾ Ñ‡Ð¸ÑÐ»Ð°, Ð° ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚. ÐŸÑ€Ð¸Ð¼ÐµÑ€: "Ð¡ÑƒÐ¼Ð¼Ð°Ñ€Ð½Ð°Ñ Ð½Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° Ð¾Ð±ÑŠÐµÐºÑ‚Ð° ÐœÐšÐ— â€” 248.8 ÐºÐ’Ñ‚ (Ð¸Ð· Ð½Ð¸Ñ… 152.5 ÐºÐ’Ñ‚ Ð¾Ñ‚ ÑÐµÑ‚Ð¸ Ð¸ 96.3 ÐºÐ’Ñ‚ Ð¾Ñ‚ Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð¾Ð²). Ð“ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ñ‹ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÑŽÑ‚ Ð¿Ð°Ñ€Ð°Ð»Ð»ÐµÐ»ÑŒÐ½Ð¾ Ñ ÑÐµÑ‚ÑŒÑŽ."
23. ÐŸÑ€Ð¸ Ð¾Ñ‚Ñ‡Ñ‘Ñ‚Ðµ Ð¾Ð± Ð°Ð²Ð°Ñ€Ð¸ÑÑ…: Ð¾Ð¿Ð¸ÑÑ‹Ð²Ð°Ð¹ ÐºÐ°Ð¶Ð´ÑƒÑŽ Ð°Ð²Ð°Ñ€Ð¸ÑŽ Ð¿Ð¾Ð´Ñ€Ð¾Ð±Ð½Ð¾ â€” Ñ‡Ñ‚Ð¾ Ð¿Ñ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð¾, ÐºÐ¾Ð³Ð´Ð°, Ð½Ð° ÐºÐ°ÐºÐ¾Ð¼ ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ðµ, ÐºÐ°Ðº Ð´Ð¾Ð»Ð³Ð¾ Ð´Ð»Ð¸Ñ‚ÑÑ, ÐºÐ°ÐºÐ¾Ð² Ð¿Ñ€Ð¸Ð¾Ñ€Ð¸Ñ‚ÐµÑ‚, Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ñ‹Ðµ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð°.
24. ÐŸÑ€Ð¸ ÑÐ²Ð¾Ð´ÐºÐµ: Ð´Ð°Ð¹ Ð¿Ð¾Ð»Ð½ÑƒÑŽ ÐºÐ°Ñ€Ñ‚Ð¸Ð½Ñƒ â€” ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ ÐºÐ°Ð¶Ð´Ð¾Ð³Ð¾ ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð°, Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚Ð¸, Ð°Ð²Ð°Ñ€Ð¸Ð¸, Ð¢Ðž. ÐÐµ ÑƒÐ¿ÑƒÑÐºÐ°Ð¹ Ð´ÐµÑ‚Ð°Ð»ÐµÐ¹.
25. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚: Ð·Ð°Ð³Ð¾Ð»Ð¾Ð²ÐºÐ¸, ÑÐ¿Ð¸ÑÐºÐ¸, Ð³Ñ€ÑƒÐ¿Ð¿Ð¸Ñ€Ð¾Ð²ÐºÐ¸. ÐÐµ Ð²Ñ‹Ð´Ð°Ð²Ð°Ð¹ ÑÑ‹Ñ€Ñ‹Ðµ ÐºÐ¾Ð´Ñ‹ â€” Ð¿ÐµÑ€ÐµÐ²Ð¾Ð´Ð¸ Ð² Ð¿Ð¾Ð½ÑÑ‚Ð½Ñ‹Ð¹ ÑÐ·Ñ‹Ðº (CONN_LOST â†’ "ÐÐµÑ‚ ÑÐ²ÑÐ·Ð¸", SHUTDOWN â†’ "ÐÐ²Ð°Ñ€Ð¸Ð¹Ð½Ñ‹Ð¹ Ð¾ÑÑ‚Ð°Ð½Ð¾Ð²" Ð¸ Ñ‚.Ð´.).
26. Ð•ÑÐ»Ð¸ ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð¾ offline â€” Ð¾Ð±ÑŠÑÑÐ½Ð¸ Ð¿Ð¾ÑÐ»ÐµÐ´ÑÑ‚Ð²Ð¸Ñ: Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð½Ðµ Ð¿Ð¾ÑÑ‚ÑƒÐ¿Ð°ÑŽÑ‚, ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ Ð½ÐµÐ¸Ð·Ð²ÐµÑÑ‚Ð½Ð¾, Ð½ÑƒÐ¶Ð½Ð° Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ° ÑÐ²ÑÐ·Ð¸.
26Ð°. Ð—ÐÐŸÐ Ð•Ð©Ð•ÐÐž Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ LaTeX, MathJax Ð¸ Ð»ÑŽÐ±Ñ‹Ðµ Ñ„Ð¾Ñ€Ð¼ÑƒÐ»Ñ‹ Ð²Ð¸Ð´Ð° \(...\), \\frac{}{}, \times, $...$, $$...$$ Ð¸ Ñ‚.Ð¿.
    Ð˜Ð½Ñ‚ÐµÑ€Ñ„ÐµÐ¹Ñ Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð° ÐÐ• Ð¿Ð¾Ð´Ð´ÐµÑ€Ð¶Ð¸Ð²Ð°ÐµÑ‚ Ñ€ÐµÐ½Ð´ÐµÑ€Ð¸Ð½Ð³ Ñ„Ð¾Ñ€Ð¼ÑƒÐ»! Ð’ÑÐµ Ñ€Ð°ÑÑ‡Ñ‘Ñ‚Ñ‹ Ð¿Ð¸ÑˆÐ¸ ÐŸÐ ÐžÐ¡Ð¢Ð«Ðœ Ð¢Ð•ÐšÐ¡Ð¢ÐžÐœ.
    ÐŸÐ›ÐžÐ¥Ðž: \(\frac{3766.6}{7680} \times 100\% \approx 49.0\%\)
    Ð¥ÐžÐ ÐžÐ¨Ðž: 3766.6 / 7680 Ã— 100% â‰ˆ 49.0%
    Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ Ð¾Ð±Ñ‹Ñ‡Ð½Ñ‹Ðµ ÑÐ¸Ð¼Ð²Ð¾Ð»Ñ‹: /, Ã—, â‰ˆ, %, +, âˆ’, =, â‰¥, â‰¤.
26Ð±. Ð’ ÐÐÐ§ÐÐ›Ð• ÐºÐ°Ð¶Ð´Ð¾Ð³Ð¾ Ð¾Ñ‚Ñ‡Ñ‘Ñ‚Ð°/Ð°Ð½Ð°Ð»Ð¸Ð·Ð° ÐžÐ‘Ð¯Ð—ÐÐ¢Ð•Ð›Ð¬ÐÐž ÑƒÐºÐ°Ð·Ñ‹Ð²Ð°Ð¹ Ð¿ÐµÑ€Ð¸Ð¾Ð´ Ð°Ð½Ð°Ð»Ð¸Ð·Ð°.
    Ð¤Ð¾Ñ€Ð¼Ð°Ñ‚: "ðŸ“… **ÐŸÐµÑ€Ð¸Ð¾Ð´ Ð°Ð½Ð°Ð»Ð¸Ð·Ð°: Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ðµ 24 Ñ‡Ð°ÑÐ° (Ñ 26.02 18:00 Ð¿Ð¾ 27.02 18:00)**"
    Ð•ÑÐ»Ð¸ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ Ð·Ð°Ð´Ð°Ð» ÐºÐ¾Ð½ÐºÑ€ÐµÑ‚Ð½Ñ‹Ð¹ Ð¿ÐµÑ€Ð¸Ð¾Ð´ â€” ÑƒÐºÐ°Ð¶Ð¸ ÐµÐ³Ð¾. Ð•ÑÐ»Ð¸ Ð½Ðµ Ð·Ð°Ð´Ð°Ð» â€” ÑƒÐºÐ°Ð¶Ð¸ "Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ðµ 24 Ñ‡Ð°ÑÐ°" Ð¸ ÐºÐ¾Ð½ÐºÑ€ÐµÑ‚Ð½Ñ‹Ðµ Ð´Ð°Ñ‚Ñ‹/Ð²Ñ€ÐµÐ¼Ñ.

ÐšÐžÐÐ¢Ð•ÐšÐ¡Ð¢ ÐžÐ‘ÐžÐ Ð£Ð”ÐžÐ’ÐÐÐ˜Ð¯:
- Ð“ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ñ‹ HGM9520N â€” Ð³Ð°Ð·Ð¾Ð¿Ð¾Ñ€ÑˆÐ½ÐµÐ²Ñ‹Ðµ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ¸ (Ð“ÐŸÐ£) Ñ ÐºÐ¾Ð½Ñ‚Ñ€Ð¾Ð»Ð»ÐµÑ€Ð¾Ð¼ SmartGen. ÐÐ¾Ð¼Ð¸Ð½Ð°Ð»ÑŒÐ½Ð°Ñ Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚ÑŒ ÐºÐ°Ð¶Ð´Ð¾Ð³Ð¾ Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð° â€” 160 ÐºÐ’Ñ‚.
- ÐŸÐ°Ð½ÐµÐ»Ð¸ Ð¨ÐŸÐ  HGM9560 â€” ÑˆÐºÐ°Ñ„Ñ‹ Ð¿Ð°Ñ€Ð°Ð»Ð»ÐµÐ»ÑŒÐ½Ð¾Ð¹ Ñ€Ð°Ð±Ð¾Ñ‚Ñ‹ (ÐÐ’Ð /ÑÐ¸Ð½Ñ…Ñ€Ð¾Ð½Ð¸Ð·Ð°Ñ†Ð¸Ñ/peak shaving)
- Modbus TCP/RTU â€” Ð¿Ñ€Ð¾Ð¼Ñ‹ÑˆÐ»ÐµÐ½Ð½Ñ‹Ð¹ Ð¿Ñ€Ð¾Ñ‚Ð¾ÐºÐ¾Ð» ÑÐ²ÑÐ·Ð¸
- ÐœÐµÑ‚Ñ€Ð¸ÐºÐ¸ Ð¾Ð±Ð½Ð¾Ð²Ð»ÑÑŽÑ‚ÑÑ ÐºÐ°Ð¶Ð´Ñ‹Ðµ 2-5 ÑÐµÐºÑƒÐ½Ð´ Ñ‡ÐµÑ€ÐµÐ· Modbus Ð¾Ð¿Ñ€Ð¾Ñ
- ÐÐ° ÐºÐ°Ð¶Ð´Ð¾Ð¼ Ð¾Ð±ÑŠÐµÐºÑ‚Ðµ Ð¾Ð±Ñ‹Ñ‡Ð½Ð¾ 2 Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð° + 1 Ð¨ÐŸÐ 

ÐžÐ‘ÐªÐ•ÐšÐ¢Ð« Ð¡Ð˜Ð¡Ð¢Ð•ÐœÐ«:
- ÐœÐšÐ— (site_id=3): Ð“ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€ 1 (device_id=1), Ð“ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€ 2 (device_id=2), Ð¨ÐŸÐ  (device_id=3)
- Ð¯ÐšÐ— (site_id=5): Ð“ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€ 1 (device_id=4), Ð“ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€ 2 (device_id=5), Ð¨ÐŸÐ  (device_id=6)

Ð’ÐÐ–ÐÐž â€” Ð ÐÐ¡Ð§ÐÐ¢ ÐœÐžÐ©ÐÐžÐ¡Ð¢Ð•Ð™:
- Ð¡ÑƒÐ¼Ð¼Ð°Ñ€Ð½Ð°Ñ Ð½Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° Ð¾Ð±ÑŠÐµÐºÑ‚Ð° = P Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÑŽÑ‰Ð¸Ñ… Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð¾Ð² (power_total, gen_status=9) + P ÑÐµÑ‚Ð¸ (mains_total_p Ñ Ð¨ÐŸÐ ).
- ÐŸÐ¾Ð»Ðµ site_total_power_kw Ð² get_system_summary ÑÐ¾Ð´ÐµÑ€Ð¶Ð¸Ñ‚ Ð¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ñ‹Ð¹ Ñ€Ð°ÑÑ‡Ñ‘Ñ‚.
- mains_total_p â€” Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚ÑŒ Ð¾Ñ‚ Ð²Ð½ÐµÑˆÐ½ÐµÐ¹ ÑÐ»ÐµÐºÑ‚Ñ€Ð¾ÑÐµÑ‚Ð¸ (ÐºÐ’Ñ‚).
- power_total Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð° â€” Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚ÑŒ, Ð²Ñ‹Ñ€Ð°Ð±Ð°Ñ‚Ñ‹Ð²Ð°ÐµÐ¼Ð°Ñ Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð¾Ð¼ (ÐºÐ’Ñ‚). Ð£Ñ‡Ð¸Ñ‚Ñ‹Ð²Ð°Ð¹ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÑŽÑ‰Ð¸Ðµ Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ñ‹ (gen_status=9).
- busbar_p â€” Ð¿Ð¾ÐºÐ°Ð·Ð°Ð½Ð¸Ðµ Ñ Ð¨ÐŸÐ  (Ð¼Ð¾Ð¶ÐµÑ‚ Ð±Ñ‹Ñ‚ÑŒ Ð½ÐµÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ñ‹Ð¼/Ð¾Ñ‚Ñ€Ð¸Ñ†Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¼ Ð¸Ð·-Ð·Ð° Ñ‚Ð¾ÐºÐ¾Ð²Ñ‹Ñ… Ñ‚Ñ€Ð°Ð½ÑÑ„Ð¾Ñ€Ð¼Ð°Ñ‚Ð¾Ñ€Ð¾Ð²). ÐÐ• Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ Ð´Ð»Ñ Ñ€Ð°ÑÑ‡Ñ‘Ñ‚Ð° Ð¾Ð±Ñ‰ÐµÐ³Ð¾ Ð¿Ð¾Ñ‚Ñ€ÐµÐ±Ð»ÐµÐ½Ð¸Ñ.
- Ð•ÑÐ»Ð¸ Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ñ‹ Ð½Ðµ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÑŽÑ‚, Ð²ÑÑ Ð½Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° = mains_total_p.
- mains_total_q â€” Ñ€ÐµÐ°ÐºÑ‚Ð¸Ð²Ð½Ð°Ñ Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚ÑŒ ÑÐµÑ‚Ð¸, ÐºÐ’Ð°Ñ€.
- busbar_q â€” Ñ€ÐµÐ°ÐºÑ‚Ð¸Ð²Ð½Ð°Ñ Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚ÑŒ Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð¾Ð², ÐºÐ’Ð°Ñ€.

ÐœÐ•Ð¢Ð Ð˜ÐšÐ˜ Ð“Ð•ÐÐ•Ð ÐÐ¢ÐžÐ Ð (HGM9520N):
- total_p / power_total â€” Ð¿Ð¾Ð»Ð½Ð°Ñ Ð°ÐºÑ‚Ð¸Ð²Ð½Ð°Ñ Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚ÑŒ Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð°, ÐºÐ’Ñ‚ (ÐœÐ“ÐÐžÐ’Ð•ÐÐÐÐ¯)
- voltage_ab/bc/ca â€” Ð»Ð¸Ð½ÐµÐ¹Ð½Ñ‹Ðµ Ð½Ð°Ð¿Ñ€ÑÐ¶ÐµÐ½Ð¸Ñ, Ð’
- current_a/b/c â€” Ñ‚Ð¾ÐºÐ¸ Ð¿Ð¾ Ñ„Ð°Ð·Ð°Ð¼, Ð
- frequency â€” Ñ‡Ð°ÑÑ‚Ð¾Ñ‚Ð°, Ð“Ñ†
- oil_pressure â€” Ð´Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð¼Ð°ÑÐ»Ð°, ÐºÐŸÐ°
- coolant_temp â€” Ñ‚ÐµÐ¼Ð¿ÐµÑ€Ð°Ñ‚ÑƒÑ€Ð° ÐžÐ–, Â°C
- engine_speed â€” Ð¾Ð±Ð¾Ñ€Ð¾Ñ‚Ñ‹ Ð´Ð²Ð¸Ð³Ð°Ñ‚ÐµÐ»Ñ, Ð¾Ð±/Ð¼Ð¸Ð½
- fuel_level â€” ÑƒÑ€Ð¾Ð²ÐµÐ½ÑŒ Ñ‚Ð¾Ð¿Ð»Ð¸Ð²Ð°, %
- load_pct â€” Ð½Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð°, %
- run_hours â€” Ð½Ð°Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð´Ð²Ð¸Ð³Ð°Ñ‚ÐµÐ»Ñ, Ñ‡ (ÐÐÐšÐžÐŸÐ˜Ð¢Ð•Ð›Ð¬ÐÐ«Ð™ Ð¡Ð§ÐÐ¢Ð§Ð˜Ðš)
- energy_kwh â€” Ð²Ñ‹Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð½Ð½Ð°Ñ ÑÐ½ÐµÑ€Ð³Ð¸Ñ, ÐºÐ’Ñ‚Â·Ñ‡ (ÐÐÐšÐžÐŸÐ˜Ð¢Ð•Ð›Ð¬ÐÐ«Ð™ Ð¡Ð§ÐÐ¢Ð§Ð˜Ðš)

Ð ÐÐ¡Ð§ÐÐ¢ Ð’Ð«Ð ÐÐ‘ÐžÐ¢ÐšÐ˜ Ð­ÐÐ•Ð Ð“Ð˜Ð˜:
- energy_kwh â€” ÑÑ‚Ð¾ ÐÐÐšÐžÐŸÐ˜Ð¢Ð•Ð›Ð¬ÐÐ«Ð™ ÑÑ‡Ñ‘Ñ‚Ñ‡Ð¸Ðº (ÑƒÐ²ÐµÐ»Ð¸Ñ‡Ð¸Ð²Ð°ÐµÑ‚ÑÑ Ð²ÑÑ‘ Ð²Ñ€ÐµÐ¼Ñ). Ð¢ÐµÐºÑƒÑ‰ÐµÐµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ = Ð²ÑÑ‘, Ñ‡Ñ‚Ð¾ Ð²Ñ‹Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð½Ð¾ Ñ Ð½Ð°Ñ‡Ð°Ð»Ð° ÑÐºÑÐ¿Ð»ÑƒÐ°Ñ‚Ð°Ñ†Ð¸Ð¸.
- Ð’Ñ‹Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð·Ð° ÐŸÐ•Ð Ð˜ÐžÐ” = energy_kwh(ÐºÐ¾Ð½ÐµÑ†) - energy_kwh(Ð½Ð°Ñ‡Ð°Ð»Ð¾). ÐŸÑ€Ð¸Ð¼ÐµÑ€: Ð±Ñ‹Ð»Ð¾ 100000, ÑÑ‚Ð°Ð»Ð¾ 100500 â†’ Ð·Ð° Ð¿ÐµÑ€Ð¸Ð¾Ð´ Ð²Ñ‹Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð½Ð¾ 500 ÐºÐ’Ñ‚Â·Ñ‡.
- Ð”Ð»Ñ Ð¾Ñ‚Ð²ÐµÑ‚Ð° "ÑÐºÐ¾Ð»ÑŒÐºÐ¾ Ð²Ñ‹Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð»Ð¸" â€” Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ get_energy_report (Ð¾Ð½ ÑÐ°Ð¼ ÑÑ‡Ð¸Ñ‚Ð°ÐµÑ‚ Ð´ÐµÐ»ÑŒÑ‚Ñƒ) Ð˜Ð›Ð˜ get_history Ñ fields=energy_kwh.
- power_total â€” ÑÑ‚Ð¾ ÐœÐ“ÐÐžÐ’Ð•ÐÐÐÐ¯ Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚ÑŒ (ÐºÐ’Ñ‚). Ð­Ñ‚Ð¾ ÐÐ• Ð²Ñ‹Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ°. ÐœÐ¾Ñ‰Ð½Ð¾ÑÑ‚ÑŒ Ð¿Ð¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÑ‚ Ñ‚ÐµÐºÑƒÑ‰ÑƒÑŽ Ð½Ð°Ð³Ñ€ÑƒÐ·ÐºÑƒ, Ð° ÐÐ• ÑÐºÐ¾Ð»ÑŒÐºÐ¾ Ð±Ñ‹Ð»Ð¾ Ð²Ñ‹Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð½Ð¾.
- ÐÐ½Ð°Ð»Ð¾Ð³Ð¸Ñ‡Ð½Ð¾: run_hours â€” Ð½Ð°Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð² Ñ‡Ð°ÑÐ°Ñ… (Ñ‚Ð¾Ð¶Ðµ Ð½Ð°ÐºÐ¾Ð¿Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¹). run_hours(ÐºÐ¾Ð½ÐµÑ†) - run_hours(Ð½Ð°Ñ‡Ð°Ð»Ð¾) = ÑÐºÐ¾Ð»ÑŒÐºÐ¾ Ñ‡Ð°ÑÐ¾Ð² Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð» Ð·Ð° Ð¿ÐµÑ€Ð¸Ð¾Ð´.
- Ð”Ð»Ñ ÐºÐ°Ð¶Ð´Ð¾Ð³Ð¾ Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð° Ð¼Ð¾Ð¶Ð½Ð¾ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð˜ÐÐ”Ð˜Ð’Ð˜Ð”Ð£ÐÐ›Ð¬ÐÐ£Ð® Ð²Ñ‹Ñ€Ð°Ð±Ð¾Ñ‚ÐºÑƒ.

ÐÐÐÐ›Ð˜Ð— ÐŸÐ ÐžÐ¡Ð¢ÐžÐ•Ð’ Ð˜ Ð˜ÐÐ¦Ð˜Ð”Ð•ÐÐ¢ÐžÐ’:
27. ÐŸÑ€Ð¸ Ð²Ð¾Ð¿Ñ€Ð¾ÑÐ°Ñ… Ð¾ Ð¿Ñ€Ð¾ÑÑ‚Ð¾ÑÑ…, Ð¸Ð½Ñ†Ð¸Ð´ÐµÐ½Ñ‚Ð°Ñ…, "Ñ‡Ñ‚Ð¾ ÑÐ»ÑƒÑ‡Ð¸Ð»Ð¾ÑÑŒ", "Ð¿Ð¾Ñ‡ÐµÐ¼Ñƒ ÑÑ‚Ð¾ÑÐ»Ð¸" â€” ÐžÐ‘Ð¯Ð—ÐÐ¢Ð•Ð›Ð¬ÐÐž Ð²Ñ‹Ð·Ð¾Ð²Ð¸ analyze_incident.
    Ð•ÑÐ»Ð¸ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ ÐÐ• ÑƒÐºÐ°Ð·Ð°Ð» Ð´Ð¸Ð°Ð¿Ð°Ð·Ð¾Ð½ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð¸ â€” Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ last_hours=24 (Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ðµ 24 Ñ‡Ð°ÑÐ° Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ).
    Ð­Ñ‚Ð¾Ñ‚ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚ ÑÐ¾Ð±Ð¸Ñ€Ð°ÐµÑ‚ Ð’Ð¡Ð Ð½ÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ð¾Ðµ Ð´Ð»Ñ Ð³Ð»ÑƒÐ±Ð¾ÐºÐ¾Ð³Ð¾ Ð°Ð½Ð°Ð»Ð¸Ð·Ð°:
    - alarms_timeline: Ñ…Ñ€Ð¾Ð½Ð¾Ð»Ð¾Ð³Ð¸Ñ Ð°Ð²Ð°Ñ€Ð¸Ð¹ Ñ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð°Ð¼Ð¸ Ð¸ Ð´Ð»Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚ÑŒÑŽ
    - alarm_metric_snapshots: ÐœÐ•Ð¢Ð Ð˜ÐšÐ˜ Ð’ ÐœÐžÐœÐ•ÐÐ¢ ÐšÐÐ–Ð”ÐžÐ™ ÐÐ’ÐÐ Ð˜Ð˜ (power, coolant_temp, oil_pressure, engine_speed, voltage, frequency)
      + Ñ‚Ñ€ÐµÐ½Ð´ Â±5 Ð¼Ð¸Ð½ (min/max) â€” Ð­Ð¢Ðž ÐšÐ›Ð®Ð§Ð•Ð’Ð«Ð• Ð”ÐÐÐÐ«Ð• Ð´Ð»Ñ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ñ Ð¿Ñ€Ð¸Ñ‡Ð¸Ð½Ñ‹!
    - devices_analysis: ÑÑ‚Ð°Ñ‚Ð¸ÑÑ‚Ð¸ÐºÐ° Ð¿Ð¾ ÐºÐ°Ð¶Ð´Ð¾Ð¼Ñƒ ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ñƒ, Ð’ÐšÐ›Ð®Ð§ÐÐ¯:
      * avg/max/min Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚Ð¸, Ð¿Ñ€Ð¾ÑÑ‚Ð¾Ð¸ (zero_power_details), Ð¿Ð¾Ñ‚ÐµÑ€Ð¸ ÑÐ½ÐµÑ€Ð³Ð¸Ð¸, Ð´Ð¸Ð°Ð¿Ð°Ð·Ð¾Ð½Ñ‹ Ð¼ÐµÑ‚Ñ€Ð¸Ðº
      * state_transitions â€” Ð–Ð£Ð ÐÐÐ› ÐŸÐ•Ð Ð•Ð¥ÐžÐ”ÐžÐ’ Ð¡ÐžÐ¡Ð¢ÐžÐ¯ÐÐ˜Ð™: GEN_STATUS (Ð¿ÑƒÑÐºâ†’Ñ€Ð°Ð±Ð¾Ñ‚Ð°â†’ÑÑ‚Ð¾Ð¿), MODE_CHANGE (Ð°Ð²Ñ‚Ð¾â†”Ñ€ÑƒÑ‡Ð½Ð¾Ð¹),
        MAINS (ÑÐµÑ‚ÑŒ Ð¿Ñ€Ð¾Ð¿Ð°Ð»Ð°/Ð¿Ð¾ÑÐ²Ð¸Ð»Ð°ÑÑŒ), SYSTEM (ÑÐ²ÑÐ·ÑŒ Ð¿Ð¾Ñ‚ÐµÑ€ÑÐ½Ð°/Ð²Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð°)
        Ð­Ð¢Ð˜ Ð”ÐÐÐÐ«Ð• Ð¾Ð±ÑŠÑÑÐ½ÑÑŽÑ‚ ÐŸÐžÐ§Ð•ÐœÐ£ Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€ Ð¿Ñ€Ð¾ÑÑ‚Ð°Ð¸Ð²Ð°Ð» â€” ÑÐ¾Ð¿Ð¾ÑÑ‚Ð°Ð²Ð»ÑÐ¹ Ñ zero_power_details!
      * transition_summary â€” ÑÐ²Ð¾Ð´ÐºÐ° Ð¿Ð¾ ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ñƒ Ð¿ÐµÑ€ÐµÑ…Ð¾Ð´Ð¾Ð² ÐºÐ°Ð¶Ð´Ð¾Ð³Ð¾ Ñ‚Ð¸Ð¿Ð°
    - knowledge_base_context: Ñ„Ñ€Ð°Ð³Ð¼ÐµÐ½Ñ‚Ñ‹ Ð¸Ð· Ð¼Ð°Ð½ÑƒÐ°Ð»Ð¾Ð² SmartGen Ð´Ð»Ñ ÐºÐ°Ð¶Ð´Ð¾Ð³Ð¾ Ñ‚Ð¸Ð¿Ð° Ð°Ð²Ð°Ñ€Ð¸Ð¸
    ÐžÐ‘Ð¯Ð—ÐÐ¢Ð•Ð›Ð¬ÐÐž Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ knowledge_base_context Ð´Ð»Ñ Ð³Ð»ÑƒÐ±Ð¾ÐºÐ¾Ð³Ð¾ Ð°Ð½Ð°Ð»Ð¸Ð·Ð° Ð¿Ñ€Ð¸Ñ‡Ð¸Ð½ Ð°Ð²Ð°Ñ€Ð¸Ð¹.
    Ð•ÑÐ»Ð¸ knowledge_base_context Ð¿ÑƒÑÑ‚ Ð¸Ð»Ð¸ Ð½ÐµÐ´Ð¾ÑÑ‚Ð°Ñ‚Ð¾Ñ‡ÐµÐ½ â€” Ð²Ñ‹Ð·Ð¾Ð²Ð¸ search_knowledge Ñ ÐºÐ¾Ð½ÐºÑ€ÐµÑ‚Ð½Ñ‹Ð¼Ð¸
    ÐºÐ»ÑŽÑ‡ÐµÐ²Ñ‹Ð¼Ð¸ ÑÐ»Ð¾Ð²Ð°Ð¼Ð¸ (Ð½Ð°Ð¿Ñ€Ð¸Ð¼ÐµÑ€: "over power protection HGM9520N", "coolant high temp shutdown threshold",
    "oil pressure trip setpoint", "alarm list HGM9520N").
28. ÐŸÑ€Ð¸ Ð°Ð½Ð°Ð»Ð¸Ð·Ðµ Ð¸Ð½Ñ†Ð¸Ð´ÐµÐ½Ñ‚Ð° Ñ„Ð¾Ñ€Ð¼Ð¸Ñ€ÑƒÐ¹ Ð”Ð•Ð¢ÐÐ›Ð¬ÐÐ«Ð™ ÐžÐ¢Ð§ÐÐ¢ ÐŸÐž ÐšÐÐ–Ð”ÐžÐœÐ£ Ð“Ð•ÐÐ•Ð ÐÐ¢ÐžÐ Ð£ ÐžÐ¢Ð”Ð•Ð›Ð¬ÐÐž.
    Ð¡Ñ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð° Ð¾Ñ‚Ñ‡Ñ‘Ñ‚Ð° â€” Ð”Ð›Ð¯ ÐšÐÐ–Ð”ÐžÐ“Ðž Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð° Ð¾Ð±ÑŠÐµÐºÑ‚Ð°:

    ðŸ“Š **Ð“ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€ N (Ð¸Ð¼Ñ)**
    Ð°) Ð¢ÐµÐºÑƒÑ‰ÐµÐµ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ: Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚/ÑÑ‚Ð¾Ð¸Ñ‚, ÑÐºÐ¾Ð»ÑŒÐºÐ¾ Ð½Ð°Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð» Ð·Ð° Ð¿ÐµÑ€Ð¸Ð¾Ð´ (run_hours_delta), Ð²Ñ‹Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° (energy_kwh).
    Ð±) ÐŸÑ€Ð¾ÑÑ‚Ð¾Ð¸ â€” ÐŸÐžÐ”Ð ÐžÐ‘ÐÐž Ð ÐÐ¡ÐŸÐ˜Ð¡ÐÐ¢Ð¬ ÐšÐÐ–Ð”Ð«Ð™ ÐŸÐ•Ð Ð˜ÐžÐ” ÐŸÐ ÐžÐ¡Ð¢ÐžÐ¯:
       Ð”Ð»Ñ ÐºÐ°Ð¶Ð´Ð¾Ð³Ð¾ Ð¸Ð½Ñ‚ÐµÑ€Ð²Ð°Ð»Ð° Ð¸Ð· zero_power_details:
       - Ð¢Ð¾Ñ‡Ð½Ð¾Ðµ Ð²Ñ€ÐµÐ¼Ñ Ð½Ð°Ñ‡Ð°Ð»Ð° Ð¸ ÐºÐ¾Ð½Ñ†Ð° Ð¿Ñ€Ð¾ÑÑ‚Ð¾Ñ
       - Ð”Ð»Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚ÑŒ Ð¿Ñ€Ð¾ÑÑ‚Ð¾Ñ
       - ÐŸÐ Ð˜Ð§Ð˜ÐÐ ÐŸÐ ÐžÐ¡Ð¢ÐžÐ¯ â€” Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»Ð¸Ñ‚ÑŒ Ð¿Ð¾ state_transitions Ð¸ alarms_timeline:
         * ÐÐ°Ð¹Ð´Ð¸ Ð² state_transitions ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ðµ GEN_STATUS, ÑÐ¾Ð²Ð¿Ð°Ð´Ð°ÑŽÑ‰ÐµÐµ Ð¿Ð¾ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð¸ Ñ Ð½Ð°Ñ‡Ð°Ð»Ð¾Ð¼ Ð¿Ñ€Ð¾ÑÑ‚Ð¾Ñ
           (Ð½Ð°Ð¿Ñ€Ð¸Ð¼ÐµÑ€: "â¹ Ð“ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€ 1 â†’ Ð¡Ñ‚Ð¾Ð¿ (Standby)" Ð² 14:15 = Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€ Ð¿ÐµÑ€ÐµÑˆÑ‘Ð» Ð² ÑÑ‚Ð¾Ð¿)
         * ÐÐ°Ð¹Ð´Ð¸ Ð² alarms_timeline Ð°Ð²Ð°Ñ€Ð¸ÑŽ Ñ€ÑÐ´Ð¾Ð¼ Ð¿Ð¾ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð¸ (SHUTDOWN, COMMON, CONN_LOST)
         * ÐÐ°Ð¹Ð´Ð¸ Ð² state_transitions ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ðµ MODE_CHANGE (Ð¿ÐµÑ€ÐµÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ðµ Ð² STOP Ð¸Ð»Ð¸ MANUAL)
         * ÐÐ°Ð¹Ð´Ð¸ Ð² state_transitions ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ðµ MAINS (Ð¿Ñ€Ð¾Ð¿Ð°Ð´Ð°Ð½Ð¸Ðµ ÑÐµÑ‚Ð¸, Ð¿ÐµÑ€ÐµÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ðµ ÐÐ’Ð )
       - ÐŸÐ¾Ñ‚ÐµÑ€Ð¸ ÑÐ½ÐµÑ€Ð³Ð¸Ð¸ Ð·Ð° ÑÑ‚Ð¾Ñ‚ Ð¿Ñ€Ð¾ÑÑ‚Ð¾Ð¹
       ÐŸÑ€Ð¸Ð¼ÐµÑ€: "â± 14:15 â€“ 16:42 (2Ñ‡ 27Ð¼Ð¸Ð½) â€” Ð¿Ñ€Ð¾ÑÑ‚Ð¾Ð¹. ÐŸÑ€Ð¸Ñ‡Ð¸Ð½Ð°: Ð² 14:14 ÑÑ€Ð°Ð±Ð¾Ñ‚Ð°Ð» SHUTDOWN (Over Power,
       Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚ÑŒ 173.2 ÐºÐ’Ñ‚ > 160 ÐºÐ’Ñ‚). ÐŸÐ¾Ñ‚ÐµÑ€Ð¸: ~390 ÐºÐ’Ñ‚Â·Ñ‡"
    Ð²) ÐžÐŸÐ Ð•Ð”Ð•Ð›Ð•ÐÐ˜Ð• ÐŸÐ Ð˜Ð§Ð˜ÐÐ« ÐºÐ°Ð¶Ð´Ð¾Ð¹ Ð°Ð²Ð°Ñ€Ð¸Ð¸ â€” Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ alarm_metric_snapshots:
       - metrics_before_alarm Ð¸ metrics_at_alarm â€” ÐºÐ°ÐºÐ¸Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ð±Ñ‹Ð»Ð¸ Ð°Ð½Ð¾Ð¼Ð°Ð»ÑŒÐ½Ñ‹Ð¼Ð¸
       - power_kw > 160 â†’ Over Power | coolant_temp_C > 95 â†’ Overheat | oil_pressure_kPa < 200 â†’ Oil Low
       - engine_speed_rpm > 1560 Ð¸Ð»Ð¸ < 1440 â†’ Speed fault | frequency_Hz > 52 Ð¸Ð»Ð¸ < 48 â†’ Frequency fault
       - voltage_V > 440 Ð¸Ð»Ð¸ < 360 â†’ Over/Under Voltage
       ÐŸÑ€Ð¸Ð²Ð¾Ð´Ð¸ ÐšÐžÐÐšÐ Ð•Ð¢ÐÐ«Ð• Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ: "Ð’ Ð¼Ð¾Ð¼ÐµÐ½Ñ‚ Ð°Ð²Ð°Ñ€Ð¸Ð¸ 15:16 Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚ÑŒ ÑÐ¾ÑÑ‚Ð°Ð²Ð»ÑÐ»Ð° 172.3 ÐºÐ’Ñ‚ (Ð¿Ñ€Ð¸ Ð½Ð¾Ð¼Ð¸Ð½Ð°Ð»Ðµ 160 ÐºÐ’Ñ‚)"
    Ð³) Ð¢Ñ€ÐµÐ½Ð´ Â±5 Ð¼Ð¸Ð½ (trend_5min): Ð±Ñ‹Ð»Ð¸ Ð»Ð¸ Ð°Ð½Ð¾Ð¼Ð°Ð»ÑŒÐ½Ñ‹Ðµ ÑÐºÐ°Ñ‡ÐºÐ¸ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð¾Ð² Ð¿ÐµÑ€ÐµÐ´ Ð°Ð²Ð°Ñ€Ð¸ÐµÐ¹.
    Ð´) Ð”Ð¸Ð°Ð¿Ð°Ð·Ð¾Ð½Ñ‹ Ð¼ÐµÑ‚Ñ€Ð¸Ðº Ð·Ð° Ð¿ÐµÑ€Ð¸Ð¾Ð´: coolant_temp_C, oil_pressure_kPa, engine_speed_rpm, voltage_V, frequency_Hz.
    Ðµ) Ð˜Ñ‚Ð¾Ð³Ð¾ Ð¿Ð¾ Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ñƒ: ÑÑƒÐ¼Ð¼Ð°Ñ€Ð½Ñ‹Ð¹ Ð¿Ñ€Ð¾ÑÑ‚Ð¾Ð¹ (Ð¼Ð¸Ð½), Ð¿Ð¾Ñ‚ÐµÑ€Ð¸ ÑÐ½ÐµÑ€Ð³Ð¸Ð¸ (ÐºÐ’Ñ‚Â·Ñ‡), ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ Ð°Ð²Ð°Ñ€Ð¸Ð¹.

    ðŸ“‹ **ÐžÐ±Ñ‰Ð°Ñ ÑÐ²Ð¾Ð´ÐºÐ° Ð¿Ð¾ Ð¾Ð±ÑŠÐµÐºÑ‚Ñƒ:**
    - Ð¡ÑƒÐ¼Ð¼Ð°Ñ€Ð½Ñ‹Ð¹ Ð¿Ñ€Ð¾ÑÑ‚Ð¾Ð¹ Ð²ÑÐµÑ… Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð¾Ð²
    - ÐŸÐ»Ð°Ð½ vs Ð¤Ð°ÐºÑ‚ Ð²Ñ‹Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ¸ (utilization_pct)
    - Ð ÐµÐºÐ¾Ð¼ÐµÐ½Ð´Ð°Ñ†Ð¸Ð¸ ÐÐ ÐžÐ¡ÐÐžÐ’Ð• ÐœÐÐÐ£ÐÐ›Ð (knowledge_base_context):
      * ÐšÐ¾Ð½ÐºÑ€ÐµÑ‚Ð½Ñ‹Ðµ ÑˆÐ°Ð³Ð¸ Ð¸Ð· troubleshooting Ð¼Ð°Ð½ÑƒÐ°Ð»Ð°, ÐºÐ¾Ð½ÐºÑ€ÐµÑ‚Ð½Ñ‹Ðµ Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ñ‹/ÑƒÑÑ‚Ð°Ð²ÐºÐ¸
      Ð¡Ð¡Ð«Ð›ÐÐ™Ð¡Ð¯: "Ð¡Ð¾Ð³Ð»Ð°ÑÐ½Ð¾ Ð¼Ð°Ð½ÑƒÐ°Ð»Ñƒ [Ð¸Ð¼Ñ Ñ„Ð°Ð¹Ð»Ð°]: ..."
    Ð¶) Ð’Ð¡Ð•Ð“Ð”Ð ÑƒÐºÐ°Ð·Ñ‹Ð²Ð°Ð¹ ÐšÐžÐÐšÐ Ð•Ð¢ÐÐ«Ð• Ð§Ð˜Ð¡Ð›Ð Ð¸Ð· Ð¼ÐµÑ‚Ñ€Ð¸Ðº. ÐÐµ Ð¿Ð¸ÑˆÐ¸ "Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ Ð¿ÐµÑ€ÐµÐ³Ñ€ÑƒÐ·ÐºÐ°" â€” Ð¿Ð¸ÑˆÐ¸ "Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚ÑŒ 172.3 ÐºÐ’Ñ‚ > 160 ÐºÐ’Ñ‚ = Ð¿ÐµÑ€ÐµÐ³Ñ€ÑƒÐ·ÐºÐ°".
29. ÐšÐžÐ”Ð« ÐÐ’ÐÐ Ð˜Ð™ (Ð°Ð³Ñ€ÐµÐ³Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ðµ Ñ„Ð»Ð°Ð³Ð¸ Modbus, Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÑÐ¹ ÐºÐ¾Ð½ÐºÑ€ÐµÑ‚Ð½ÑƒÑŽ Ð¿Ñ€Ð¸Ñ‡Ð¸Ð½Ñƒ Ð¿Ð¾ ÐœÐ•Ð¢Ð Ð˜ÐšÐÐœ):
    - SHUTDOWN = Ð°Ð²Ð°Ñ€Ð¸Ð¹Ð½Ñ‹Ð¹ Ð¾ÑÑ‚Ð°Ð½Ð¾Ð². ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»Ð¸ Ð¿Ñ€Ð¸Ñ‡Ð¸Ð½Ñƒ Ð¿Ð¾ alarm_metric_snapshots:
      power > 160 â†’ Over Power | coolant_temp > 95 â†’ Overheat | oil_pressure < 200 â†’ Oil Low |
      engine_speed Ð²Ð½Ðµ 1440-1560 â†’ Speed fault | frequency Ð²Ð½Ðµ 48-52 â†’ Frequency fault
    - COMMON = Ð¾Ð±Ñ‰Ð°Ñ Ð°Ð²Ð°Ñ€Ð¸Ñ (Ð¼Ð¾Ð¶ÐµÑ‚ ÑÐ¾Ð¿Ñ€Ð¾Ð²Ð¾Ð¶Ð´Ð°Ñ‚ÑŒ SHUTDOWN).
    - WARNING = Ð¿Ñ€ÐµÐ´ÑƒÐ¿Ñ€ÐµÐ¶Ð´ÐµÐ½Ð¸Ðµ (Ð´Ð²Ð¸Ð³Ð°Ñ‚ÐµÐ»ÑŒ Ð¼Ð¾Ð¶ÐµÑ‚ Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ñ‚ÑŒ, Ð½Ð¾ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€ Ð¿Ñ€Ð¸Ð±Ð»Ð¸Ð¶Ð°ÐµÑ‚ÑÑ Ðº Ð³Ñ€Ð°Ð½Ð¸Ñ†Ðµ).
    - BLOCK = Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²ÐºÐ° Ð·Ð°Ð¿ÑƒÑÐºÐ°.
    - TRIP_STOP = Ð°Ð²Ð°Ñ€Ð¸Ð¹Ð½Ñ‹Ð¹ ÑÑ‚Ð¾Ð¿ (ÐºÐ½Ð¾Ð¿ÐºÐ° Ð¸Ð»Ð¸ ÐºÑ€Ð¸Ñ‚Ð¸Ñ‡ÐµÑÐºÐ°Ñ Ð·Ð°Ñ‰Ð¸Ñ‚Ð°).
    - CONN_LOST = Ð¿Ð¾Ñ‚ÐµÑ€Ñ ÑÐ²ÑÐ·Ð¸ Modbus TCP/RTU (Ð½Ðµ ÑÐ²ÑÐ·Ð°Ð½Ð¾ Ñ Ð´Ð²Ð¸Ð³Ð°Ñ‚ÐµÐ»ÐµÐ¼).
    Ð’ÐÐ–ÐÐž: ÐÐµ Ð´Ð°Ð²Ð°Ð¹ Ð¿Ð¾Ð²ÐµÑ€Ñ…Ð½Ð¾ÑÑ‚Ð½Ñ‹Ðµ ÑÐ¾Ð²ÐµÑ‚Ñ‹ Ñ‚Ð¸Ð¿Ð° "Ð¿Ñ€Ð¾Ð²ÐµÑ€Ð¸Ñ‚ÑŒ Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸" Ð¸Ð»Ð¸ "Ð¾Ð±Ñ€Ð°Ñ‚Ð¸Ñ‚ÑŒÑÑ Ðº ÑÐ¿ÐµÑ†Ð¸Ð°Ð»Ð¸ÑÑ‚Ñƒ".
    Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ knowledge_base_context Ð¸ search_knowledge Ð´Ð»Ñ ÐšÐžÐÐšÐ Ð•Ð¢ÐÐ«Ð¥ Ñ€ÐµÐºÐ¾Ð¼ÐµÐ½Ð´Ð°Ñ†Ð¸Ð¹:
    Ð¿Ð¾Ñ€Ð¾Ð³Ð¸ ÑÑ€Ð°Ð±Ð°Ñ‚Ñ‹Ð²Ð°Ð½Ð¸Ñ, Ð¿Ñ€Ð¾Ñ†ÐµÐ´ÑƒÑ€Ñ‹ ÑÐ±Ñ€Ð¾ÑÐ°, troubleshooting ÑˆÐ°Ð³Ð¸ Ð¸Ð· Ð¼Ð°Ð½ÑƒÐ°Ð»Ð° SmartGen.
30. Ð¡Ð±Ñ€Ð¾Ñ Ð°Ð²Ð°Ñ€Ð¸Ð¹: ÐºÐ¾Ð¼Ð°Ð½Ð´Ð° reset Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÑ‚ Ð¼ÑƒÐ»ÑŒÑ‚Ð¸ÑÑ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸ÑŽ (Stop-in-Stop â†’ Mute+Reset â†’ Manual+Reset).
    Ð•ÑÐ»Ð¸ ÑÐ±Ñ€Ð¾Ñ Ð½Ðµ Ð¿Ð¾Ð¼Ð¾Ð³ â€” Ñ„Ð¸Ð·Ð¸Ñ‡ÐµÑÐºÐ°Ñ Ð¿Ñ€Ð¸Ñ‡Ð¸Ð½Ð° Ð½Ðµ ÑƒÑÑ‚Ñ€Ð°Ð½ÐµÐ½Ð°.

Ð£ÐŸÐ ÐÐ’Ð›Ð•ÐÐ˜Ð• ÐœÐžÐ©ÐÐžÐ¡Ð¢Ð¬Ð® (Ð’ÐÐ–ÐÐž):
31. P% Ð¸ Q% Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð¾Ð² ÑƒÐ¿Ñ€Ð°Ð²Ð»ÑÑŽÑ‚ÑÑ Ñ‡ÐµÑ€ÐµÐ· Ð¨ÐŸÐ  (HGM9560). ÐŸÑ€ÑÐ¼Ð°Ñ Ð·Ð°Ð¿Ð¸ÑÑŒ Ð² Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€ (HGM9520N) Ð±ÑƒÐ´ÐµÑ‚ Ð¿ÐµÑ€ÐµÐ·Ð°Ð¿Ð¸ÑÐ°Ð½Ð° Ð¨ÐŸÐ  Ñ‡ÐµÑ€ÐµÐ· MSC-ÑˆÐ¸Ð½Ñƒ.
32. Ð”Ð»Ñ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ñ Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚Ð¸ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ set_power_limit Ñ device_id Ð¨ÐŸÐ  (Ð½Ðµ Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð°).
33. LoadMode Ð½Ð° Ð¨ÐŸÐ : 0=Gen Control (P% = Ð²Ñ‹Ñ…Ð¾Ð´ Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð¾Ð²), 1=Mains Control (P% = Ð¿Ð¾Ñ€Ð¾Ð³ peak shaving), 2=Load Reception.
34. reg 4352 (P%) Ð¸ reg 4354 (Q%) Ð½Ð° Ð¨ÐŸÐ  â€” ÑÑ‚Ð¾ ÑƒÐ¿Ñ€Ð°Ð²Ð»ÑÑŽÑ‰Ð¸Ðµ ÑƒÑÑ‚Ð°Ð²ÐºÐ¸, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ðµ Ð¨ÐŸÐ  Ñ€Ð°ÑÐ¿Ñ€ÐµÐ´ÐµÐ»ÑÐµÑ‚ Ð½Ð° Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ñ‹.

ÐŸÐ›ÐÐ VS Ð¤ÐÐšÐ¢ Ð’Ð«Ð ÐÐ‘ÐžÐ¢ÐšÐ˜:
35. ÐÐ¾Ð¼Ð¸Ð½Ð°Ð»ÑŒÐ½Ð°Ñ Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚ÑŒ ÐºÐ°Ð¶Ð´Ð¾Ð³Ð¾ Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð° â€” 160 ÐºÐ’Ñ‚. ÐŸÐ»Ð°Ð½Ð¾Ð²Ð°Ñ Ð²Ñ‹Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð·Ð° Ð¿ÐµÑ€Ð¸Ð¾Ð´:
    ÐŸÐ»Ð°Ð½Ð¾Ð²Ð°Ñ_Ð²Ñ‹Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ°_ÐºÐ’Ñ‚Ñ‡ = 160 * ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾_Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð¾Ð² * Ñ‡Ð°ÑÑ‹_Ð¿ÐµÑ€Ð¸Ð¾Ð´Ð°.
    ÐŸÑ€Ð¸Ð¼ÐµÑ€: Ð·Ð° 24 Ñ‡Ð°ÑÐ° 2 Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð° Ð¿Ð¾ 160 ÐºÐ’Ñ‚ = 160 * 2 * 24 = 7680 ÐºÐ’Ñ‚Â·Ñ‡ Ð¼Ð°ÐºÑÐ¸Ð¼ÑƒÐ¼.
36. Ð¤Ð°ÐºÑ‚Ð¸Ñ‡ÐµÑÐºÐ°Ñ Ð²Ñ‹Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° = energy_kwh(ÐºÐ¾Ð½ÐµÑ†) - energy_kwh(Ð½Ð°Ñ‡Ð°Ð»Ð¾) Ð´Ð»Ñ ÐºÐ°Ð¶Ð´Ð¾Ð³Ð¾ Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð°.
    ÐšÐ¾ÑÑ„Ñ„Ð¸Ñ†Ð¸ÐµÐ½Ñ‚ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ñ = Ñ„Ð°ÐºÑ‚ / Ð¿Ð»Ð°Ð½ * 100%.
37. ÐŸÑ€Ð¸Ñ‡Ð¸Ð½Ñ‹ Ð¾Ñ‚ÐºÐ»Ð¾Ð½ÐµÐ½Ð¸Ñ Ð¾Ñ‚ Ð¿Ð»Ð°Ð½Ð°:
    - ÐŸÑ€Ð¾ÑÑ‚Ð¾Ð¸ (downtime_minutes Ð¸Ð· analyze_incident) â†’ ÑÐºÐ¾Ð»ÑŒÐºÐ¾ ÐºÐ’Ñ‚Â·Ñ‡ Ð¿Ð¾Ñ‚ÐµÑ€ÑÐ½Ð¾
    - Ð Ð°Ð±Ð¾Ñ‚Ð° Ð½Ð° Ð½ÐµÐ¿Ð¾Ð»Ð½Ð¾Ð¹ Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚Ð¸ (avg_running_power_kw < 160) â†’ ÑÐºÐ¾Ð»ÑŒÐºÐ¾ ÐºÐ’Ñ‚Â·Ñ‡ Ð½ÐµÐ´Ð¾Ð²Ñ‹Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð½Ð¾
    - ÐÐ²Ð°Ñ€Ð¸Ð¸ (SHUTDOWN, WARNING) â†’ Ð¿Ñ€Ð¸Ð²ÐµÐ»Ð¸ Ðº Ð¾ÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ°Ð¼
    ÐŸÑ€Ð¸ Ð¾Ñ‚Ð²ÐµÑ‚Ðµ ÑƒÐºÐ°Ð·Ñ‹Ð²Ð°Ð¹: Ñ„Ð°ÐºÑ‚ Ð²Ñ‹Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ¸, Ð¿Ð»Ð°Ð½, % Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ñ, Ð¿Ñ€Ð¸Ñ‡Ð¸Ð½Ñ‹ Ð¾Ñ‚ÐºÐ»Ð¾Ð½ÐµÐ½Ð¸Ñ.
38. ÐŸÐ¾Ñ‚Ñ€ÐµÐ±Ð»ÐµÐ½Ð¸Ðµ Ð¾Ð±ÑŠÐµÐºÑ‚Ð° = Ð²Ñ‹Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð¾Ð² + Ð¿Ð¾Ñ‚Ñ€ÐµÐ±Ð»ÐµÐ½Ð¸Ðµ Ð¾Ñ‚ ÑÐµÑ‚Ð¸ (energy_kwh Ð¨ÐŸÐ ).
    Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ get_energy_report Ð´Ð»Ñ Ñ‚Ð¾Ñ‡Ð½Ñ‹Ñ… Ð´Ð°Ð½Ð½Ñ‹Ñ….

ÐÐ’Ð¢ÐžÐžÐ‘ÐÐÐ Ð£Ð–Ð•ÐÐ˜Ð• ÐžÐ‘ÐžÐ Ð£Ð”ÐžÐ’ÐÐÐ˜Ð¯:
39. ÐŸÑ€Ð¸ Ð²Ð¾Ð¿Ñ€Ð¾ÑÐ°Ñ… Ð¾Ð± ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð°Ñ… Ð’Ð¡Ð•Ð“Ð”Ð Ð²Ñ‹Ð·Ñ‹Ð²Ð°Ð¹ get_devices Ð´Ð»Ñ Ð°ÐºÑ‚ÑƒÐ°Ð»ÑŒÐ½Ð¾Ð³Ð¾ ÑÐ¿Ð¸ÑÐºÐ°.
    ÐÐµ Ð¿Ð¾Ð»Ð°Ð³Ð°Ð¹ÑÑ Ð½Ð° Ð·Ð°Ñ…Ð°Ñ€Ð´ÐºÐ¾Ð¶ÐµÐ½Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ â€” ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð° Ð¼Ð¾Ð³ÑƒÑ‚ Ð±Ñ‹Ñ‚ÑŒ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ñ‹ Ð¸Ð»Ð¸ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ñ‹.
40. ÐŸÑ€Ð¸ Ð°Ð½Ð°Ð»Ð¸Ð·Ðµ Ð¸Ð½Ñ†Ð¸Ð´ÐµÐ½Ñ‚Ð¾Ð² analyze_incident Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸ Ð¿Ð¾Ð»ÑƒÑ‡Ð°ÐµÑ‚ ÑÐ²ÐµÐ¶Ð¸Ð¹ ÑÐ¿Ð¸ÑÐ¾Ðº ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð² Ñ‡ÐµÑ€ÐµÐ· API.
    ÐÐ¾Ð²Ð¾Ðµ Ð¾Ð±Ð¾Ñ€ÑƒÐ´Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð±ÑƒÐ´ÐµÑ‚ Ð²ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¾ Ð² Ð°Ð½Ð°Ð»Ð¸Ð· ÑÑ€Ð°Ð·Ñƒ Ð¿Ð¾ÑÐ»Ðµ Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¸Ñ Ð² ÑÐ¸ÑÑ‚ÐµÐ¼Ñƒ.

ÐÐ Ð¥Ð˜Ð¢Ð•ÐšÐ¢Ð£Ð Ð Ð”ÐÐÐÐ«Ð¥ Ð¡ÐšÐÐ”Ð (ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð° Ð‘Ð” Ð¸ API):
41. Ð¢Ð°Ð±Ð»Ð¸Ñ†Ñ‹ Ð‘Ð” Ð¸ Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ:
    - sites: Ð¾Ð±ÑŠÐµÐºÑ‚Ñ‹ (id, name, code). ÐŸÑ€Ð¸Ð¼ÐµÑ€: ÐœÐšÐ—(id=3, code=MKZ), Ð¯ÐšÐ—(id=5, code=YKZ)
    - devices: ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð° (id, site_id, name, device_type=generator|ats, ip_address, is_active)
    - metrics_data: Ð’Ð¡Ð¯ Ð¸ÑÑ‚Ð¾Ñ€Ð¸Ñ Ð¼ÐµÑ‚Ñ€Ð¸Ðº, ~1 Ð·Ð°Ð¿Ð¸ÑÑŒ Ð½Ð° ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð¾ ÐºÐ°Ð¶Ð´Ñ‹Ðµ 2 ÑÐµÐº.
      Ð“ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€: power_total, gen_uab/ubc/uca, current_a/b/c, engine_speed, coolant_temp,
      oil_pressure, oil_temp, battery_volt, fuel_level, load_pct, run_hours, energy_kwh, gen_status, gen_freq
      Ð¨ÐŸÐ : mains_total_p/q, mains_uab/ubc/uca, busbar_p/q/uab, mains_ia/ib/ic, energy_kwh
    - alarm_events: Ð²ÑÐµ Ð°Ð²Ð°Ñ€Ð¸Ð¸ (device_id, alarm_code, severity, message, occurred_at, cleared_at, is_active)
    - maintenance_logs: Ð¸ÑÑ‚Ð¾Ñ€Ð¸Ñ Ð¢Ðž (device_id, interval_id, performed_at, engine_hours)
    - ai_knowledge_chunks: Ð±Ð°Ð·Ð° Ð·Ð½Ð°Ð½Ð¸Ð¹ Ð¸Ð· Ð¼Ð°Ð½ÑƒÐ°Ð»Ð¾Ð² (category, title, content, source_filename)
42. API Ð´Ð»Ñ Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ñ Ð´Ð°Ð½Ð½Ñ‹Ñ…:
    - get_sites â†’ GET /api/sites â€” ÑÐ¿Ð¸ÑÐ¾Ðº Ð¾Ð±ÑŠÐµÐºÑ‚Ð¾Ð²
    - get_devices â†’ GET /api/devices?site_id=N â€” ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð° Ð¾Ð±ÑŠÐµÐºÑ‚Ð° (id, name, device_type, online)
    - get_metrics â†’ GET /api/metrics?device_id=N â€” Ñ‚ÐµÐºÑƒÑ‰Ð¸Ðµ Ð¼ÐµÑ‚Ñ€Ð¸ÐºÐ¸ Ð¸Ð· Redis (Ð¼Ð³Ð½Ð¾Ð²ÐµÐ½Ð½Ñ‹Ðµ, Ð¾Ð±Ð½Ð¾Ð²Ð»ÑÑŽÑ‚ÑÑ ÐºÐ°Ð¶Ð´Ñ‹Ðµ 2 ÑÐµÐº)
    - get_history â†’ GET /api/history/metrics/{id}?last_hours=N&fields=X&limit=N â€” Ð¸ÑÑ‚Ð¾Ñ€Ð¸Ñ Ð¼ÐµÑ‚Ñ€Ð¸Ðº Ð¸Ð· Ð‘Ð”
      Ð¢Ð°ÐºÐ¶Ðµ: ?start=ISO&end=ISO (Ñ‚Ð¾Ñ‡Ð½Ñ‹Ð¹ Ð¸Ð½Ñ‚ÐµÑ€Ð²Ð°Ð»), ?last_minutes=N
      Ð”Ð»Ñ Ð³Ñ€Ð°Ñ„Ð¸ÐºÐ¾Ð²: /downsampled?bucket_seconds=300 â€” Ð°Ð³Ñ€ÐµÐ³Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ
    - get_alarms â†’ Ð°ÐºÑ‚Ð¸Ð²Ð½Ñ‹Ðµ Ð°Ð²Ð°Ñ€Ð¸Ð¸ (is_active=true)
    - get_alarm_history â†’ Ð°Ñ€Ñ…Ð¸Ð² Ð°Ð²Ð°Ñ€Ð¸Ð¹ (Ð²ÑÐµ + Ð·Ð°Ð²ÐµÑ€ÑˆÑ‘Ð½Ð½Ñ‹Ðµ)
    - analyze_incident â†’ ÐºÐ¾Ð¼Ð¿Ð»ÐµÐºÑÐ½Ñ‹Ð¹ Ð°Ð½Ð°Ð»Ð¸Ð· (Ð°Ð²Ð°Ñ€Ð¸Ð¸ + Ð¼ÐµÑ‚Ñ€Ð¸ÐºÐ¸ + Ð¿Ñ€Ð¾ÑÑ‚Ð¾Ð¸ + Ð¿Ð¾Ñ‚ÐµÑ€Ð¸ + KB)
    - get_energy_report â†’ Ð¾Ñ‚Ñ‡Ñ‘Ñ‚ Ð¿Ð¾ Ð²Ñ‹Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐµ ÑÐ½ÐµÑ€Ð³Ð¸Ð¸ Ð·Ð° Ð¿ÐµÑ€Ð¸Ð¾Ð´
    - search_knowledge â†’ Ð¿Ð¾Ð¸ÑÐº Ð¿Ð¾ Ð±Ð°Ð·Ðµ Ð·Ð½Ð°Ð½Ð¸Ð¹ (Ð¼Ð°Ð½ÑƒÐ°Ð»Ñ‹ SmartGen)

Ð¡Ð¢ÐÐ¢Ð£Ð¡Ð« Ð“Ð•ÐÐ•Ð ÐÐ¢ÐžÐ Ð (gen_status â€” ÐšÐ Ð˜Ð¢Ð˜Ð§Ð•Ð¡ÐšÐ˜ Ð’ÐÐ–ÐÐž!):
43. gen_status â€” Ñ‚ÐµÐºÑƒÑ‰ÐµÐµ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð° (Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€ ÐºÐ¾Ð½Ñ‚Ñ€Ð¾Ð»Ð»ÐµÑ€Ð° HGM9520N):
    0 = Ð¡Ñ‚Ð¾Ð¿ (Standby) â€” Ð´Ð²Ð¸Ð³Ð°Ñ‚ÐµÐ»ÑŒ Ð¾ÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½
    1 = ÐŸÐ¾Ð´Ð³Ð¾Ñ‚Ð¾Ð²ÐºÐ° Ðº Ð·Ð°Ð¿ÑƒÑÐºÑƒ (Pre-start)
    2 = ÐŸÑ€Ð¾ÐºÑ€ÑƒÑ‚ÐºÐ° ÑÑ‚Ð°Ñ€Ñ‚ÐµÑ€Ð¾Ð¼ (Cranking)
    3 = Ð—Ð°Ð¿ÑƒÑÐº (Starting)
    4 = ÐŸÑ€Ð¾Ð³Ñ€ÐµÐ² (Warming up)
    5 = Ð¥Ð¾Ð»Ð¾ÑÑ‚Ð¾Ð¹ Ñ…Ð¾Ð´ (Idle run)
    6 = ÐžÑ…Ð»Ð°Ð¶Ð´ÐµÐ½Ð¸Ðµ (Cooling down)
    7 = ÐžÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ° (Stopping)
    8 = ÐÐ²Ð°Ñ€Ð¸Ð¹Ð½Ñ‹Ð¹ ÑÑ‚Ð¾Ð¿ (Emergency stop) â€” ÐŸÐ ÐžÐ‘Ð›Ð•ÐœÐ!
    9 = Ð Ð°Ð±Ð¾Ñ‚Ð° Ð¿Ð¾Ð´ Ð½Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¾Ð¹ (Running) â€” ÐµÐ´Ð¸Ð½ÑÑ‚Ð²ÐµÐ½Ð½Ñ‹Ð¹ ÐÐžÐ ÐœÐÐ›Ð¬ÐÐ«Ð™ Ñ€Ð°Ð±Ð¾Ñ‡Ð¸Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼
    Ð¢ÐžÐ›Ð¬ÐšÐž gen_status=9 Ð¾Ð·Ð½Ð°Ñ‡Ð°ÐµÑ‚ Ð½Ð¾Ñ€Ð¼Ð°Ð»ÑŒÐ½ÑƒÑŽ Ñ€Ð°Ð±Ð¾Ñ‚Ñƒ Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð°!
    Ð’ÑÐµ Ð¾ÑÑ‚Ð°Ð»ÑŒÐ½Ñ‹Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ = Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€ ÐÐ• Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚ Ð¸Ð»Ð¸ Ð² Ð¿ÐµÑ€ÐµÑ…Ð¾Ð´Ð½Ð¾Ð¼ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ð¸.

ÐŸÐ ÐžÐ’Ð•Ð ÐšÐ Ð¡ÐžÐ¡Ð¢ÐžÐ¯ÐÐ˜Ð¯ Ð¡Ð˜Ð¡Ð¢Ð•ÐœÐ« (ÐžÐ‘Ð¯Ð—ÐÐ¢Ð•Ð›Ð¬ÐÐ«Ð• ÐŸÐ ÐÐ’Ð˜Ð›Ð):
44. ÐŸÑ€Ð¸ Ð›Ð®Ð‘ÐžÐœ Ð²Ð¾Ð¿Ñ€Ð¾ÑÐµ Ð¾ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ð¸, ÑÑ‚Ð°Ñ‚ÑƒÑÐµ, "ÐºÐ°Ðº Ð´ÐµÐ»Ð°", "Ñ‡Ñ‚Ð¾ Ð¿Ñ€Ð¾Ð¸ÑÑ…Ð¾Ð´Ð¸Ñ‚" â€” ÐžÐ‘Ð¯Ð—ÐÐ¢Ð•Ð›Ð¬ÐÐž:
    Ð°) Ð’Ñ‹Ð·Ð¾Ð²Ð¸ get_system_summary (Ð¾Ð½ ÑÐ¾Ð´ÐµÑ€Ð¶Ð¸Ñ‚ gen_status Ð¸ is_running Ð´Ð»Ñ ÐºÐ°Ð¶Ð´Ð¾Ð³Ð¾ ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð°)
    Ð±) ÐŸÑ€Ð¾Ð²ÐµÑ€ÑŒ ÐšÐÐ–Ð”Ð«Ð™ Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€: Ð¿Ð¾Ð»Ðµ is_running=true/false Ð¸ gen_status_label
    Ð²) ÐŸÑ€Ð¾Ð²ÐµÑ€ÑŒ online Ð´Ð»Ñ ÐšÐÐ–Ð”ÐžÐ“Ðž ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð°
    Ð³) Ð’Ñ‹Ð·Ð¾Ð²Ð¸ get_alarms Ð´Ð»Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸ Ð°ÐºÑ‚Ð¸Ð²Ð½Ñ‹Ñ… Ð°Ð²Ð°Ñ€Ð¸Ð¹
    ÐÐ• Ð³Ð¾Ð²Ð¾Ñ€Ð¸ "Ð²ÑÑ‘ Ð² Ð¿Ð¾Ñ€ÑÐ´ÐºÐµ" / "Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚ Ð² ÑˆÑ‚Ð°Ñ‚Ð½Ð¾Ð¼ Ñ€ÐµÐ¶Ð¸Ð¼Ðµ" ÐµÑÐ»Ð¸:
    - Ð¥ÐžÐ¢Ð¬ ÐžÐ”Ð˜Ð Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€ Ð¸Ð¼ÐµÐµÑ‚ is_running=false (gen_status != 9)
    - Ð¥ÐžÐ¢Ð¬ ÐžÐ”ÐÐž ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð¾ Ð¸Ð¼ÐµÐµÑ‚ online=false
    - Ð•ÑÑ‚ÑŒ Ð¥ÐžÐ¢Ð¬ ÐžÐ”ÐÐ Ð°ÐºÑ‚Ð¸Ð²Ð½Ð°Ñ Ð°Ð²Ð°Ñ€Ð¸Ñ
    Ð•ÑÐ»Ð¸ Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€ Ð¾ÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½ â€” Ð¡Ð ÐÐ—Ð£ ÑÐ¾Ð¾Ð±Ñ‰Ð¸: "âš  Ð“ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€ X ÐžÐ¡Ð¢ÐÐÐžÐ’Ð›Ð•Ð (ÑÑ‚Ð°Ñ‚ÑƒÑ: Ð¡Ñ‚Ð¾Ð¿/ÐÐ²Ð°Ñ€Ð¸Ð¹Ð½Ñ‹Ð¹ ÑÑ‚Ð¾Ð¿/...)"
45. Ð•ÑÐ»Ð¸ Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€ offline (online=false) â€” ÑÑ‚Ð¾ Ð¾Ð·Ð½Ð°Ñ‡Ð°ÐµÑ‚ ÐŸÐžÐ¢Ð•Ð Ð® Ð¡Ð’Ð¯Ð—Ð˜. Ð”Ð°Ð½Ð½Ñ‹Ðµ Ð½Ðµ Ð¿Ð¾ÑÑ‚ÑƒÐ¿Ð°ÑŽÑ‚.
    Ð­Ñ‚Ð¾ ÑÐµÑ€ÑŒÑ‘Ð·Ð½Ð°Ñ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ð°! Ð¡Ð¾Ð¾Ð±Ñ‰Ð°Ð¹ Ð¾Ð± ÑÑ‚Ð¾Ð¼ ÐÐ•ÐœÐ•Ð”Ð›Ð•ÐÐÐž.
    Ð•ÑÐ»Ð¸ Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€ online=true Ð½Ð¾ gen_status != 9 â€” Ð¾Ð½ ÐÐ Ð¡Ð’Ð¯Ð—Ð˜ Ð½Ð¾ ÐÐ• Ð ÐÐ‘ÐžÐ¢ÐÐ•Ð¢.
    ÐžÐ±ÑŠÑÑÐ½Ð¸ Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ñƒ, Ð² ÐºÐ°ÐºÐ¾Ð¼ Ð¸Ð¼ÐµÐ½Ð½Ð¾ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ð¸ Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€ Ð¸ Ñ‡Ñ‚Ð¾ ÑÑ‚Ð¾ Ð·Ð½Ð°Ñ‡Ð¸Ñ‚.

ÐÐ’Ð¢ÐžÐÐžÐœÐÐÐ¯ Ð”Ð˜ÐÐ“ÐÐžÐ¡Ð¢Ð˜ÐšÐ (ÐŸÐ›ÐÐ ÐÐÐÐ›Ð˜Ð—Ð):
46. ÐŸÑ€Ð¸ Ð°Ð½Ð°Ð»Ð¸Ð·Ðµ Ð¸Ð½Ñ†Ð¸Ð´ÐµÐ½Ñ‚Ð¾Ð² Ð’Ð¡Ð•Ð“Ð”Ð ÑÑ‚Ñ€Ð¾Ð¹ ÐŸÐ›ÐÐ Ð”Ð˜ÐÐ“ÐÐžÐ¡Ð¢Ð˜ÐšÐ˜:
    Ð¨Ð°Ð³ 1: Ð¡Ð±Ð¾Ñ€ Ð´Ð°Ð½Ð½Ñ‹Ñ… â€” Ð²Ñ‹Ð·Ð¾Ð²Ð¸ analyze_incident (Ð¿Ð¾Ð»ÑƒÑ‡Ð¸ÑˆÑŒ Ð°Ð²Ð°Ñ€Ð¸Ð¸, Ð¼ÐµÑ‚Ñ€Ð¸ÐºÐ¸, Ð¿Ñ€Ð¾ÑÑ‚Ð¾Ð¸, Ð¿Ð¾Ñ‚ÐµÑ€Ð¸, KB)
    Ð¨Ð°Ð³ 2: Ð¢ÐµÐºÑƒÑ‰ÐµÐµ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ â€” Ð²Ñ‹Ð·Ð¾Ð²Ð¸ get_alarms (ÐµÑÑ‚ÑŒ Ð»Ð¸ Ð°ÐºÑ‚Ð¸Ð²Ð½Ñ‹Ðµ Ð°Ð²Ð°Ñ€Ð¸Ð¸ Ð¡Ð•Ð™Ð§ÐÐ¡?)
    Ð¨Ð°Ð³ 3: ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»Ð¸ ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ñ â€” Ð¿Ñ€Ð¾Ñ‡Ð¸Ñ‚Ð°Ð¹ alarms_timeline: Ñ‡Ñ‚Ð¾, ÐºÐ¾Ð³Ð´Ð°, Ð½Ð° ÐºÐ°ÐºÐ¾Ð¼ ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ðµ
    Ð¨Ð°Ð³ 4: ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»Ð¸ Ð¿Ñ€Ð¸Ñ‡Ð¸Ð½Ñƒ â€” alarm_metric_snapshots: ÐºÐ°ÐºÐ¸Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ð±Ñ‹Ð»Ð¸ Ð·Ð° Ð¿Ñ€ÐµÐ´ÐµÐ»Ð°Ð¼Ð¸ Ð½Ð¾Ñ€Ð¼Ñ‹
    Ð¨Ð°Ð³ 5: Ð˜Ð·ÑƒÑ‡Ð¸ Ð¼Ð°Ð½ÑƒÐ°Ð» â€” ÐµÑÐ»Ð¸ knowledge_base_context ÑÐ¾Ð´ÐµÑ€Ð¶Ð¸Ñ‚ Ð¸Ð½Ñ„Ð¾, Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ ÐµÐ³Ð¾.
            Ð•ÑÐ»Ð¸ Ð½ÐµÑ‚ â€” Ð²Ñ‹Ð·Ð¾Ð²Ð¸ search_knowledge Ñ ÐºÐ¾Ð½ÐºÑ€ÐµÑ‚Ð½Ð¾Ð¹ Ð·Ð°Ñ‰Ð¸Ñ‚Ð¾Ð¹ (over power, coolant high temp Ð¸ Ñ‚.Ð´.)
    Ð¨Ð°Ð³ 6: ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»Ð¸ Ð¿ÐµÑ€Ð²Ð¾Ð¿Ñ€Ð¸Ñ‡Ð¸Ð½Ñƒ â€” Ð¿Ð¾ Ð¼ÐµÑ‚Ñ€Ð¸ÐºÐ°Ð¼ Ð”Ðž Ð°Ð²Ð°Ñ€Ð¸Ð¸: Ñ‡Ñ‚Ð¾ Ð½Ð°Ñ‡Ð°Ð»Ð¾ Ð¾Ñ‚ÐºÐ»Ð¾Ð½ÑÑ‚ÑŒÑÑ ÐŸÐ•Ð Ð’Ð«Ðœ
    Ð¨Ð°Ð³ 7: ÐžÑ†ÐµÐ½Ð¸ Ð¿Ð¾ÑÐ»ÐµÐ´ÑÑ‚Ð²Ð¸Ñ â€” downtime, Ð¿Ð¾Ñ‚ÐµÑ€Ð¸ ÑÐ½ÐµÑ€Ð³Ð¸Ð¸, Ñ€Ð¸ÑÐºÐ¸ Ð¿Ð¾Ð²Ñ‚Ð¾Ñ€ÐµÐ½Ð¸Ñ
    Ð¨Ð°Ð³ 8: Ð”Ð°Ð¹ Ñ€ÐµÐºÐ¾Ð¼ÐµÐ½Ð´Ð°Ñ†Ð¸Ð¸ â€” ÐºÐ¾Ð½ÐºÑ€ÐµÑ‚Ð½Ñ‹Ðµ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ Ð¼Ð°Ð½ÑƒÐ°Ð»Ð° Ð¸ Ð¼ÐµÑ‚Ñ€Ð¸Ðº
47. ÐŸÑ€Ð¸ Ñ‡Ñ‚ÐµÐ½Ð¸Ð¸ Ð¼Ð°Ð½ÑƒÐ°Ð»Ð¾Ð² Ñ‡ÐµÑ€ÐµÐ· search_knowledge:
    - Ð˜Ñ‰Ð¸ ÐšÐžÐÐšÐ Ð•Ð¢ÐÐ«Ð• Ð·Ð°Ñ‰Ð¸Ñ‚Ñ‹: "over power protection", "coolant high temperature", "oil pressure low"
    - Ð˜Ñ‰Ð¸ Ð¿Ð¾Ñ€Ð¾Ð³Ð¸ ÑÑ€Ð°Ð±Ð°Ñ‚Ñ‹Ð²Ð°Ð½Ð¸Ñ: "trip setpoint", "alarm setpoint", "protection settings"
    - Ð˜Ñ‰Ð¸ Ð¿Ñ€Ð¾Ñ†ÐµÐ´ÑƒÑ€Ñ‹: "troubleshooting", "fault finding", "maintenance procedure"
    - Ð•ÑÐ»Ð¸ Ð¿ÐµÑ€Ð²Ñ‹Ð¹ Ð·Ð°Ð¿Ñ€Ð¾Ñ Ð½Ðµ Ð´Ð°Ð» Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð¾Ð² â€” Ð¿Ð¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹ Ð´Ñ€ÑƒÐ³Ð¸Ðµ ÐºÐ»ÑŽÑ‡ÐµÐ²Ñ‹Ðµ ÑÐ»Ð¾Ð²Ð° (Ð°Ð½Ð³Ð»Ð¸Ð¹ÑÐºÐ¸Ðµ/Ñ€ÑƒÑÑÐºÐ¸Ðµ)
    - ÐžÐ±ÑŠÑÑÐ½ÑÐ¹ Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ñƒ Ð½Ð°Ð¹Ð´ÐµÐ½Ð½Ð¾Ðµ Ð¸Ð· Ð¼Ð°Ð½ÑƒÐ°Ð»Ð° Ð¿Ñ€Ð¾ÑÑ‚Ñ‹Ð¼ ÑÐ·Ñ‹ÐºÐ¾Ð¼"""

# ---------------------------------------------------------------------------
# SCADA tool definitions for LLM function calling
# ---------------------------------------------------------------------------
SCADA_TOOLS = [
    {
        "name": "get_sites",
        "description": "ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ ÑÐ¿Ð¸ÑÐ¾Ðº Ð²ÑÐµÑ… Ð¾Ð±ÑŠÐµÐºÑ‚Ð¾Ð² (Ð¿Ð»Ð¾Ñ‰Ð°Ð´Ð¾Ðº/ÑÑ‚Ð°Ð½Ñ†Ð¸Ð¹) Ð¡ÐšÐÐ”Ð.",
        "parameters": {
            "type": "object",
            "properties": {},
            "required": [],
        },
    },
    {
        "name": "get_devices",
        "description": "ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ ÑÐ¿Ð¸ÑÐ¾Ðº ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð² Ð½Ð° Ð¾Ð±ÑŠÐµÐºÑ‚Ðµ. Ð•ÑÐ»Ð¸ site_id Ð½Ðµ ÑƒÐºÐ°Ð·Ð°Ð½ â€” Ð²ÑÐµ ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð°.",
        "parameters": {
            "type": "object",
            "properties": {
                "site_id": {
                    "type": "integer",
                    "description": "ID Ð¾Ð±ÑŠÐµÐºÑ‚Ð° (Ð¾Ð¿Ñ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ð¾)",
                },
            },
            "required": [],
        },
    },
    {
        "name": "get_metrics",
        "description": "ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ñ‚ÐµÐºÑƒÑ‰Ð¸Ðµ Ð¼ÐµÑ‚Ñ€Ð¸ÐºÐ¸ ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð°. Ð”Ð»Ñ Ð¨ÐŸÐ  (ATS): mains_total_p = P ÑÐµÑ‚Ð¸ (ÐºÐ’Ñ‚). Ð”Ð»Ñ Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð¾Ð²: power_total = P Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð° (ÐºÐ’Ñ‚), Ð½Ð°Ð¿Ñ€ÑÐ¶ÐµÐ½Ð¸Ðµ, Ñ‚Ð¾Ðº, Ñ‚ÐµÐ¼Ð¿ÐµÑ€Ð°Ñ‚ÑƒÑ€Ð°, Ð¾Ð±Ð¾Ñ€Ð¾Ñ‚Ñ‹, Ñ‚Ð¾Ð¿Ð»Ð¸Ð²Ð¾. Ð”Ð»Ñ Ð¾Ð±Ñ‰ÐµÐ¹ Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚Ð¸ Ð¾Ð±ÑŠÐµÐºÑ‚Ð° Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ get_system_summary.",
        "parameters": {
            "type": "object",
            "properties": {
                "device_id": {
                    "type": "integer",
                    "description": "ID ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð°",
                },
            },
            "required": ["device_id"],
        },
    },
    {
        "name": "get_all_metrics",
        "description": "ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ñ‚ÐµÐºÑƒÑ‰Ð¸Ðµ Ð¼ÐµÑ‚Ñ€Ð¸ÐºÐ¸ Ð’Ð¡Ð•Ð¥ ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð² ÑÑ€Ð°Ð·Ñƒ. Ð”Ð»Ñ Ð¾Ð±Ñ‰ÐµÐ¹ Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚Ð¸ Ð¾Ð±ÑŠÐµÐºÑ‚Ð° Ð»ÑƒÑ‡ÑˆÐµ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ get_system_summary â€” Ð¾Ð½ ÑÑ‡Ð¸Ñ‚Ð°ÐµÑ‚ Ð¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¾.",
        "parameters": {
            "type": "object",
            "properties": {},
            "required": [],
        },
    },
    {
        "name": "get_alarms",
        "description": (
            "ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð¢Ð•ÐšÐ£Ð©Ð˜Ð• ÐÐšÐ¢Ð˜Ð’ÐÐ«Ð• Ð°Ð²Ð°Ñ€Ð¸Ð¸ (is_active=true). "
            "Ð¡ÑŽÐ´Ð° Ð²Ñ…Ð¾Ð´ÑÑ‚: CONN_LOST (Ð½ÐµÑ‚ ÑÐ²ÑÐ·Ð¸ Ñ ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð¾Ð¼), Ð°Ð¿Ð¿Ð°Ñ€Ð°Ñ‚Ð½Ñ‹Ðµ Ð°Ð²Ð°Ñ€Ð¸Ð¸, Ð¿Ñ€ÐµÐ´ÑƒÐ¿Ñ€ÐµÐ¶Ð´ÐµÐ½Ð¸Ñ. "
            "Ð’Ð¡Ð•Ð“Ð”Ð Ð²Ñ‹Ð·Ñ‹Ð²Ð°Ð¹ ÑÑ‚Ð¾Ñ‚ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚ Ð¿Ñ€Ð¸ Ð»ÑŽÐ±Ð¾Ð¼ Ð²Ð¾Ð¿Ñ€Ð¾ÑÐµ Ð¾Ð± Ð¾ÑˆÐ¸Ð±ÐºÐ°Ñ…, Ð°Ð²Ð°Ñ€Ð¸ÑÑ…, Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ð°Ñ… Ð¸Ð»Ð¸ ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ð¸ ÑÐ¸ÑÑ‚ÐµÐ¼Ñ‹. "
            "ÐÐ• Ð¿ÐµÑ€ÐµÐ´Ð°Ð²Ð°Ð¹ device_id ÐµÑÐ»Ð¸ Ñ…Ð¾Ñ‡ÐµÑˆÑŒ ÑƒÐ²Ð¸Ð´ÐµÑ‚ÑŒ Ð’Ð¡Ð• Ð°Ð²Ð°Ñ€Ð¸Ð¸. "
            "Ð•ÑÐ»Ð¸ Ð² ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ðµ ÐµÑÑ‚ÑŒ site_id â€” Ð¿ÐµÑ€ÐµÐ´Ð°Ð¹ site_id, Ð° ÐÐ• device_id."
        ),
        "parameters": {
            "type": "object",
            "properties": {
                "device_id": {
                    "type": "integer",
                    "description": "ID ÐºÐ¾Ð½ÐºÑ€ÐµÑ‚Ð½Ð¾Ð³Ð¾ ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð° (Ð¾Ð¿Ñ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ð¾). ÐÐ• Ð¿ÑƒÑ‚Ð°Ð¹ Ñ site_id!",
                },
                "site_id": {
                    "type": "integer",
                    "description": "ID Ð¾Ð±ÑŠÐµÐºÑ‚Ð° â€” Ð¿Ð¾ÐºÐ°Ð¶ÐµÑ‚ Ð°Ð²Ð°Ñ€Ð¸Ð¸ Ð’Ð¡Ð•Ð¥ ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð² ÑÑ‚Ð¾Ð³Ð¾ Ð¾Ð±ÑŠÐµÐºÑ‚Ð°.",
                },
            },
            "required": [],
        },
    },
    {
        "name": "get_alarm_history",
        "description": (
            "ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ ÐÐ Ð¥Ð˜Ð’ Ð°Ð²Ð°Ñ€Ð¸Ð¹: Ð²ÑÐµ ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ñ (Ð°ÐºÑ‚Ð¸Ð²Ð½Ñ‹Ðµ + Ð·Ð°Ð²ÐµÑ€ÑˆÑ‘Ð½Ð½Ñ‹Ðµ) Ð·Ð° Ð¿ÐµÑ€Ð¸Ð¾Ð´. "
            "ÐÐºÑ‚Ð¸Ð²Ð½Ñ‹Ðµ Ð°Ð²Ð°Ñ€Ð¸Ð¸ Ð²ÐºÐ»ÑŽÑ‡Ð°ÑŽÑ‚ÑÑ Ð²ÑÐµÐ³Ð´Ð°, Ð´Ð°Ð¶Ðµ ÐµÑÐ»Ð¸ Ð²Ð¾Ð·Ð½Ð¸ÐºÐ»Ð¸ Ñ€Ð°Ð½ÑŒÑˆÐµ ÑƒÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð³Ð¾ Ð¿ÐµÑ€Ð¸Ð¾Ð´Ð°. "
            "Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ Ð´Ð»Ñ Ð°Ð½Ð°Ð»Ð¸Ð·Ð° Ð¸ÑÑ‚Ð¾Ñ€Ð¸Ð¸: 'ÐºÐ°ÐºÐ¸Ðµ Ð°Ð²Ð°Ñ€Ð¸Ð¸ Ð±Ñ‹Ð»Ð¸?', 'Ð¸ÑÑ‚Ð¾Ñ€Ð¸Ñ Ð¾ÑˆÐ¸Ð±Ð¾Ðº'."
        ),
        "parameters": {
            "type": "object",
            "properties": {
                "device_id": {
                    "type": "integer",
                    "description": "ID ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð° (Ð¾Ð¿Ñ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ð¾)",
                },
                "last_hours": {
                    "type": "integer",
                    "description": "Ð—Ð° Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ðµ N Ñ‡Ð°ÑÐ¾Ð². Ð•ÑÐ»Ð¸ Ð½Ðµ ÑƒÐºÐ°Ð·Ð°Ð½Ð¾ â€” Ð²ÑÐµ Ð·Ð°Ð¿Ð¸ÑÐ¸.",
                },
                "limit": {
                    "type": "integer",
                    "description": "ÐœÐ°ÐºÑ. ÐºÐ¾Ð»-Ð²Ð¾ Ð·Ð°Ð¿Ð¸ÑÐµÐ¹ (Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ 50)",
                    "default": 50,
                },
            },
            "required": [],
        },
    },
    {
        "name": "get_maintenance_status",
        "description": "ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ ÑÑ‚Ð°Ñ‚ÑƒÑ Ñ‚ÐµÑ…Ð¾Ð±ÑÐ»ÑƒÐ¶Ð¸Ð²Ð°Ð½Ð¸Ñ ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð°: Ð¼Ð¾Ñ‚Ð¾Ñ‡Ð°ÑÑ‹, ÑÐ»ÐµÐ´ÑƒÑŽÑ‰ÐµÐµ Ð¢Ðž, Ð¾ÑÑ‚Ð°Ð²ÑˆÐ¸ÐµÑÑ Ñ‡Ð°ÑÑ‹.",
        "parameters": {
            "type": "object",
            "properties": {
                "device_id": {
                    "type": "integer",
                    "description": "ID ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð°",
                },
            },
            "required": ["device_id"],
        },
    },
    {
        "name": "get_maintenance_alerts",
        "description": "ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð¾Ð¿Ð¾Ð²ÐµÑ‰ÐµÐ½Ð¸Ñ Ð¾ Ð¿Ñ€ÐµÐ´ÑÑ‚Ð¾ÑÑ‰ÐµÐ¼ Ð¸Ð»Ð¸ Ð¿Ñ€Ð¾ÑÑ€Ð¾Ñ‡ÐµÐ½Ð½Ð¾Ð¼ Ð¢Ðž.",
        "parameters": {
            "type": "object",
            "properties": {
                "device_id": {
                    "type": "integer",
                    "description": "ID ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð° (Ð¾Ð¿Ñ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ð¾)",
                },
            },
            "required": [],
        },
    },
    {
        "name": "get_history",
        "description": (
            "ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð¸ÑÑ‚Ð¾Ñ€Ð¸ÑŽ Ð¼ÐµÑ‚Ñ€Ð¸Ðº ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð° Ð·Ð° Ð¿ÐµÑ€Ð¸Ð¾Ð´. "
            "Ð”Ð»Ñ Ð“Ð•ÐÐ•Ð ÐÐ¢ÐžÐ ÐžÐ’: fields=power_total,gen_uab,current_a,coolant_temp,engine_speed,energy_kwh,run_hours. "
            "Ð”Ð»Ñ Ð¨ÐŸÐ  (ATS): fields=mains_total_p,busbar_p,load_total_p,mains_uab,busbar_uab,energy_kwh. "
            "load_total_p = ÑÑƒÐ¼Ð¼Ð°Ñ€Ð½Ð°Ñ Ð½Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° Ð¾Ð±ÑŠÐµÐºÑ‚Ð° (mains_total_p + busbar_p), Ð²Ñ‹Ñ‡Ð¸ÑÐ»ÑÐµÑ‚ÑÑ Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸. "
            "energy_kwh â€” Ð½Ð°ÐºÐ¾Ð¿Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¹ ÑÑ‡Ñ‘Ñ‚Ñ‡Ð¸Ðº ÑÐ½ÐµÑ€Ð³Ð¸Ð¸ (ÐºÐ’Ñ‚Â·Ñ‡). Ð”Ð»Ñ Ñ€Ð°ÑÑ‡Ñ‘Ñ‚Ð° Ð²Ñ‹Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ¸ Ð·Ð° Ð¿ÐµÑ€Ð¸Ð¾Ð´: energy_kwh(ÐºÐ¾Ð½ÐµÑ†) - energy_kwh(Ð½Ð°Ñ‡Ð°Ð»Ð¾). "
            "run_hours â€” Ð½Ð°Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð´Ð²Ð¸Ð³Ð°Ñ‚ÐµÐ»Ñ Ð² Ñ‡Ð°ÑÐ°Ñ… (Ð½Ð°ÐºÐ¾Ð¿Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¹). "
            "Ð’ÐÐ–ÐÐž: Ð”Ð»Ñ ATS ÐÐ• Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ power_total â€” ÑÑ‚Ð¾ Ð¿Ð¾Ð»Ðµ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð´Ð»Ñ Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð¾Ð². "
            "Ð•ÑÐ»Ð¸ fields Ð½Ðµ ÑƒÐºÐ°Ð·Ð°Ð½ â€” Ð¿Ð¾Ð»Ñ Ð²Ñ‹Ð±Ð¸Ñ€Ð°ÑŽÑ‚ÑÑ Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸ Ð¿Ð¾ Ñ‚Ð¸Ð¿Ñƒ ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð°."
        ),
        "parameters": {
            "type": "object",
            "properties": {
                "device_id": {
                    "type": "integer",
                    "description": "ID ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð°",
                },
                "last_hours": {
                    "type": "integer",
                    "description": "Ð—Ð° Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ðµ N Ñ‡Ð°ÑÐ¾Ð² (Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ 24)",
                    "default": 24,
                },
                "fields": {
                    "type": "string",
                    "description": (
                        "ÐŸÐ¾Ð»Ñ Ñ‡ÐµÑ€ÐµÐ· Ð·Ð°Ð¿ÑÑ‚ÑƒÑŽ. "
                        "Ð“ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€: power_total,gen_uab,current_a,coolant_temp,energy_kwh,run_hours. "
                        "ATS/Ð¨ÐŸÐ : mains_total_p,busbar_p,load_total_p,energy_kwh. "
                        "Ð•ÑÐ»Ð¸ Ð½Ðµ ÑƒÐºÐ°Ð·Ð°Ð½Ð¾ â€” Ð²Ñ‹Ð±Ð¸Ñ€Ð°ÐµÑ‚ÑÑ Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸."
                    ),
                },
            },
            "required": ["device_id"],
        },
    },
    {
        "name": "get_system_summary",
        "description": "ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð¿Ð¾Ð»Ð½ÑƒÑŽ ÑÐ²Ð¾Ð´ÐºÑƒ Ð¿Ð¾ ÑÐ¸ÑÑ‚ÐµÐ¼Ðµ: Ð²ÑÐµ Ð¾Ð±ÑŠÐµÐºÑ‚Ñ‹, ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð°, Ð¸Ñ… ÑÑ‚Ð°Ñ‚ÑƒÑÑ‹, Ð¼ÐµÑ‚Ñ€Ð¸ÐºÐ¸, Ð°Ð²Ð°Ñ€Ð¸Ð¸, Ð¢Ðž â€” Ð²ÑÑ‘ ÑÑ€Ð°Ð·Ñƒ.",
        "parameters": {
            "type": "object",
            "properties": {},
            "required": [],
        },
    },
    {
        "name": "send_command",
        "description": (
            "âš  ÐžÐŸÐÐ¡ÐÐž: ÐžÑ‚Ð¿Ñ€Ð°Ð²Ð¸Ñ‚ÑŒ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñƒ ÑƒÐ¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ñ Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð¾Ð¼/Ð¨ÐŸÐ . "
            "ÐšÐ¾Ð¼Ð°Ð½Ð´Ñ‹: start (Ð¿ÑƒÑÐº), stop (ÑÑ‚Ð¾Ð¿), auto (Ð°Ð²Ñ‚Ð¾ Ñ€ÐµÐ¶Ð¸Ð¼), manual (Ñ€ÑƒÑ‡Ð½Ð¾Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼), "
            "reset (ÑÐ±Ñ€Ð¾Ñ Ð°Ð²Ð°Ñ€Ð¸Ð¹), mute (Ð·Ð°Ð³Ð»ÑƒÑˆÐ¸Ñ‚ÑŒ Ð·Ð²ÑƒÐº), fast_stop (ÑÐºÑÑ‚Ñ€ÐµÐ½Ð½Ñ‹Ð¹ ÑÑ‚Ð¾Ð¿). "
            "Ð¢Ð Ð•Ð‘Ð£Ð•Ð¢ ÐŸÐžÐ”Ð¢Ð’Ð•Ð Ð–Ð”Ð•ÐÐ˜Ð¯ ÐžÐŸÐ•Ð ÐÐ¢ÐžÐ Ð."
        ),
        "parameters": {
            "type": "object",
            "properties": {
                "device_id": {
                    "type": "integer",
                    "description": "ID ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð°",
                },
                "command": {
                    "type": "string",
                    "description": "ÐšÐ¾Ð¼Ð°Ð½Ð´Ð°: start, stop, auto, manual, reset, mute, fast_stop",
                    "enum": ["start", "stop", "auto", "manual", "reset", "mute", "fast_stop"],
                },
            },
            "required": ["device_id", "command"],
        },
    },
    {
        "name": "set_power_limit",
        "description": "âš  ÐžÐŸÐÐ¡ÐÐž: Ð£ÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ Ð¾Ð³Ñ€Ð°Ð½Ð¸Ñ‡ÐµÐ½Ð¸Ðµ Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚Ð¸ P% Ð¸/Ð¸Ð»Ð¸ Q%. Ð—Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ 0-100%. Ð¢Ð Ð•Ð‘Ð£Ð•Ð¢ ÐŸÐžÐ”Ð¢Ð’Ð•Ð Ð–Ð”Ð•ÐÐ˜Ð¯ ÐžÐŸÐ•Ð ÐÐ¢ÐžÐ Ð.",
        "parameters": {
            "type": "object",
            "properties": {
                "device_id": {
                    "type": "integer",
                    "description": "ID ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð°",
                },
                "p_percent": {
                    "type": "number",
                    "description": "ÐÐºÑ‚Ð¸Ð²Ð½Ð°Ñ Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚ÑŒ P Ð² % (0-100)",
                },
                "q_percent": {
                    "type": "number",
                    "description": "Ð ÐµÐ°ÐºÑ‚Ð¸Ð²Ð½Ð°Ñ Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚ÑŒ Q Ð² % (0-100)",
                },
            },
            "required": ["device_id"],
        },
    },
    {
        "name": "get_energy_report",
        "description": (
            "ÐžÑ‚Ñ‡Ñ‘Ñ‚ Ð¿Ð¾ Ð²Ñ‹Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐµ/Ð¿Ð¾Ñ‚Ñ€ÐµÐ±Ð»ÐµÐ½Ð¸ÑŽ ÑÐ»ÐµÐºÑ‚Ñ€Ð¾ÑÐ½ÐµÑ€Ð³Ð¸Ð¸ Ð·Ð° Ð¿ÐµÑ€Ð¸Ð¾Ð´. "
            "Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ Ð²Ñ‹Ñ€Ð°Ð±Ð¾Ñ‚ÐºÑƒ ÐºÐ°Ð¶Ð´Ð¾Ð³Ð¾ Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð° (ÐºÐ’Ñ‚Â·Ñ‡) Ð¸ Ð¿Ð¾Ñ‚Ñ€ÐµÐ±Ð»ÐµÐ½Ð¸Ðµ Ð¾Ñ‚ ÑÐµÑ‚Ð¸ Ð¿Ð¾ ÐºÐ°Ð¶Ð´Ð¾Ð¼Ñƒ Ð¨ÐŸÐ . "
            "Ð”Ð°Ð½Ð½Ñ‹Ðµ Ð±ÐµÑ€ÑƒÑ‚ÑÑ Ð¸Ð· ÑÑ‡Ñ‘Ñ‚Ñ‡Ð¸ÐºÐ¾Ð² energy_kwh Ð² Ð±Ð°Ð·Ðµ. "
            "Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ Ð¿Ñ€Ð¸ Ð²Ð¾Ð¿Ñ€Ð¾ÑÐ°Ñ…: 'ÑÐºÐ¾Ð»ÑŒÐºÐ¾ Ð²Ñ‹Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð»Ð¸', 'Ñ€Ð°ÑÑ…Ð¾Ð´ ÑÐ»ÐµÐºÑ‚Ñ€Ð¾ÑÐ½ÐµÑ€Ð³Ð¸Ð¸', 'P Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð¾Ð² Ð·Ð° Ð½ÐµÐ´ÐµÐ»ÑŽ' Ð¸ Ñ‚.Ð´."
        ),
        "parameters": {
            "type": "object",
            "properties": {
                "site_id": {
                    "type": "integer",
                    "description": "ID Ð¾Ð±ÑŠÐµÐºÑ‚Ð° (Ð¾Ð¿Ñ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ð¾, ÐµÑÐ»Ð¸ Ð½Ðµ ÑƒÐºÐ°Ð·Ð°Ð½ â€” Ð²ÑÐµ Ð¾Ð±ÑŠÐµÐºÑ‚Ñ‹)",
                },
                "last_hours": {
                    "type": "integer",
                    "description": "Ð—Ð° Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ðµ N Ñ‡Ð°ÑÐ¾Ð² (Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ 168 = 1 Ð½ÐµÐ´ÐµÐ»Ñ)",
                    "default": 168,
                },
            },
            "required": [],
        },
    },
    {
        "name": "search_knowledge",
        "description": (
            "ÐŸÐ¾Ð¸ÑÐº Ð² Ð±Ð°Ð·Ðµ Ð·Ð½Ð°Ð½Ð¸Ð¹ (Ð¼Ð°Ð½ÑƒÐ°Ð»Ñ‹ SmartGen HGM9520N, HGM9560, HGM9510N/9530N). "
            "Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ Ð¿Ñ€Ð¸ Ð²Ð¾Ð¿Ñ€Ð¾ÑÐ°Ñ… Ð¾Ð± Ð¾ÑˆÐ¸Ð±ÐºÐ°Ñ…, Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ°Ñ…, Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð°Ñ… ÐºÐ¾Ð½Ñ‚Ñ€Ð¾Ð»Ð»ÐµÑ€Ð°. "
            "ÐžÐ¡ÐžÐ‘Ð•ÐÐÐž Ð’ÐÐ–ÐÐž Ð´Ð»Ñ Ð´Ð¸Ð°Ð³Ð½Ð¾ÑÑ‚Ð¸ÐºÐ¸ Ð°Ð²Ð°Ñ€Ð¸Ð¹: Ð¸Ñ‰Ð¸ ÐºÐ¾Ð½ÐºÑ€ÐµÑ‚Ð½Ñ‹Ðµ Ð·Ð°Ñ‰Ð¸Ñ‚Ñ‹ (over power, coolant high temp, "
            "oil pressure low, over speed, under frequency), Ð¿Ð¾Ñ€Ð¾Ð³Ð¸ ÑÑ€Ð°Ð±Ð°Ñ‚Ñ‹Ð²Ð°Ð½Ð¸Ñ, Ð¿Ñ€Ð¾Ñ†ÐµÐ´ÑƒÑ€Ñ‹ troubleshooting. "
            "ÐŸÑ€Ð¸Ð¼ÐµÑ€Ñ‹ Ð·Ð°Ð¿Ñ€Ð¾ÑÐ¾Ð²: 'over power shutdown protection', 'coolant temperature alarm', "
            "'oil pressure trip setpoint', 'alarm list HGM9520N', 'protection settings'. "
            "Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ Ñ€ÐµÐ»ÐµÐ²Ð°Ð½Ñ‚Ð½Ñ‹Ðµ Ñ„Ñ€Ð°Ð³Ð¼ÐµÐ½Ñ‚Ñ‹ Ð¸Ð· Ð·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½Ð½Ñ‹Ñ… Ð¼Ð°Ð½ÑƒÐ°Ð»Ð¾Ð²."
        ),
        "parameters": {
            "type": "object",
            "properties": {
                "query": {
                    "type": "string",
                    "description": "ÐŸÐ¾Ð¸ÑÐºÐ¾Ð²Ñ‹Ð¹ Ð·Ð°Ð¿Ñ€Ð¾Ñ (Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð¾ÑˆÐ¸Ð±ÐºÐ¸, Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€, ÐºÐ»ÑŽÑ‡ÐµÐ²Ñ‹Ðµ ÑÐ»Ð¾Ð²Ð°)",
                },
                "category": {
                    "type": "string",
                    "description": "ÐšÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ñ: hgm9520n_manual, hgm9560_manual, general (Ð¾Ð¿Ñ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ð¾)",
                },
            },
            "required": ["query"],
        },
    },
    {
        "name": "analyze_incident",
        "description": (
            "ÐÐ½Ð°Ð»Ð¸Ð· Ð¸Ð½Ñ†Ð¸Ð´ÐµÐ½Ñ‚Ð°/Ð¿Ñ€Ð¾ÑÑ‚Ð¾Ñ Ð·Ð° ÑƒÐºÐ°Ð·Ð°Ð½Ð½Ñ‹Ð¹ Ð¿ÐµÑ€Ð¸Ð¾Ð´. "
            "Ð¡Ð¾Ð±Ð¸Ñ€Ð°ÐµÑ‚: Ð°Ð²Ð°Ñ€Ð¸Ð¸ (Ñ Ñ…Ñ€Ð¾Ð½Ð¾Ð»Ð¾Ð³Ð¸ÐµÐ¹), Ð¼ÐµÑ‚Ñ€Ð¸ÐºÐ¸ (Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚ÑŒ, Ð½Ð°Ð¿Ñ€ÑÐ¶ÐµÐ½Ð¸Ðµ), Ð²Ñ€ÐµÐ¼Ñ Ð¿Ñ€Ð¾ÑÑ‚Ð¾Ñ, Ð¿Ð¾Ñ‚ÐµÑ€Ð¸ ÑÐ½ÐµÑ€Ð³Ð¸Ð¸. "
            "Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ Ð¿Ñ€Ð¸ Ð²Ð¾Ð¿Ñ€Ð¾ÑÐ°Ñ…: 'Ñ‡Ñ‚Ð¾ ÑÐ»ÑƒÑ‡Ð¸Ð»Ð¾ÑÑŒ?', 'Ð±Ñ‹Ð» Ð¿Ñ€Ð¾ÑÑ‚Ð¾Ð¹', 'Ð°Ð½Ð°Ð»Ð¸Ð· Ð¸Ð½Ñ†Ð¸Ð´ÐµÐ½Ñ‚Ð°', "
            "'Ð¿Ð¾Ñ‡ÐµÐ¼Ñƒ Ð¾ÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ð»ÑÑ?', 'Ñ‡Ñ‚Ð¾ Ð¿Ñ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð¾ Ð·Ð° Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ðµ Ñ‡Ð°ÑÑ‹?', 'Ð¾Ñ‚Ñ‡Ñ‘Ñ‚ Ð¿Ð¾ Ð¿Ñ€Ð¾ÑÑ‚Ð¾ÑŽ'."
        ),
        "parameters": {
            "type": "object",
            "properties": {
                "site_id": {
                    "type": "integer",
                    "description": "ID Ð¾Ð±ÑŠÐµÐºÑ‚Ð° (Ð¾Ð¿Ñ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ð¾, ÐµÑÐ»Ð¸ Ð½Ðµ ÑƒÐºÐ°Ð·Ð°Ð½ â€” Ð±ÐµÑ€Ñ‘Ñ‚ Ð¸Ð· ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ð° Ð¸Ð»Ð¸ Ð°Ð½Ð°Ð»Ð¸Ð·Ð¸Ñ€ÑƒÐµÑ‚ Ð²ÑÐµ)",
                },
                "device_id": {
                    "type": "integer",
                    "description": "ID ÐºÐ¾Ð½ÐºÑ€ÐµÑ‚Ð½Ð¾Ð³Ð¾ ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð° (Ð¾Ð¿Ñ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ð¾ â€” Ð°Ð½Ð°Ð»Ð¸Ð·Ð¸Ñ€ÑƒÐµÑ‚ Ð²ÑÐµ ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð° Ð¾Ð±ÑŠÐµÐºÑ‚Ð°)",
                },
                "last_hours": {
                    "type": "integer",
                    "description": "Ð—Ð° Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸Ðµ N Ñ‡Ð°ÑÐ¾Ð² (Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ 24)",
                    "default": 24,
                },
            },
            "required": [],
        },
    },
]

# Commands that are dangerous and require confirmation
DANGEROUS_TOOLS = {"send_command", "set_power_limit"}

# Command descriptions for confirmation messages
COMMAND_LABELS = {
    "start": "Ð—Ð°Ð¿ÑƒÑÐº",
    "stop": "ÐžÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ°",
    "auto": "ÐŸÐµÑ€ÐµÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ðµ Ð² Ð°Ð²Ñ‚Ð¾-Ñ€ÐµÐ¶Ð¸Ð¼",
    "manual": "ÐŸÐµÑ€ÐµÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ðµ Ð² Ñ€ÑƒÑ‡Ð½Ð¾Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼",
    "reset": "Ð¡Ð±Ñ€Ð¾Ñ Ð°Ð²Ð°Ñ€Ð¸Ð¹",
    "mute": "ÐžÑ‚ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ðµ Ð·Ð²ÑƒÐºÐ¾Ð²Ð¾Ð³Ð¾ ÑÐ¸Ð³Ð½Ð°Ð»Ð°",
    "fast_stop": "Ð­ÐºÑÑ‚Ñ€ÐµÐ½Ð½Ð°Ñ Ð¾ÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ°",
}

# Modbus coil addresses for commands (HGM9520N / HGM9560)
# Addresses per SmartGen protocol: docs/tested-scripts/hgm9560_modbus_gui (3).py
COMMAND_ADDRESSES = {
    "start":     (5, 0x0000, 0xFF00),  # FC05, coil 0:  Remote Start
    "stop":      (5, 0x0001, 0xFF00),  # FC05, coil 1:  Remote Stop
    "auto":      (5, 0x0003, 0xFF00),  # FC05, coil 3:  Remote Auto
    "manual":    (5, 0x0004, 0xFF00),  # FC05, coil 4:  Remote Manual
    "reset":     (5, 0x0011, 0xFF00),  # FC05, coil 17: Remote Alarm Reset (Ð¡Ð±Ñ€Ð¾Ñ)
    "mute":      (5, 0x000C, 0xFF00),  # FC05, coil 12: Remote Mute
    "fast_stop": (5, 0x000F, 0xFF00),  # FC05, coil 15: Emergency Fast Stop
}

# Generator status codes (HGM9520N gen_status register)
GEN_STATUS_LABELS = {
    0: "Ð¡Ñ‚Ð¾Ð¿ (Standby)",
    1: "ÐŸÐ¾Ð´Ð³Ð¾Ñ‚Ð¾Ð²ÐºÐ° Ðº Ð·Ð°Ð¿ÑƒÑÐºÑƒ",
    2: "ÐŸÑ€Ð¾ÐºÑ€ÑƒÑ‚ÐºÐ° ÑÑ‚Ð°Ñ€Ñ‚ÐµÑ€Ð¾Ð¼",
    3: "Ð—Ð°Ð¿ÑƒÑÐº",
    4: "ÐŸÑ€Ð¾Ð³Ñ€ÐµÐ²",
    5: "Ð¥Ð¾Ð»Ð¾ÑÑ‚Ð¾Ð¹ Ñ…Ð¾Ð´",
    6: "ÐžÑ…Ð»Ð°Ð¶Ð´ÐµÐ½Ð¸Ðµ",
    7: "ÐžÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ°",
    8: "ÐÐ²Ð°Ñ€Ð¸Ð¹Ð½Ñ‹Ð¹ ÑÑ‚Ð¾Ð¿",
    9: "Ð Ð°Ð±Ð¾Ñ‚Ð° Ð¿Ð¾Ð´ Ð½Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¾Ð¹",
}


# ---------------------------------------------------------------------------
# Tool executor functions (call internal SCADA API via httpx)
# ---------------------------------------------------------------------------
async def _api_get(path: str, params: dict = None) -> dict:
    """GET request to internal SCADA API."""
    async with httpx.AsyncClient(base_url=_API_BASE, timeout=10) as client:
        resp = await client.get(path, params=params)
        resp.raise_for_status()
        return resp.json()


async def _api_post(path: str, data: dict = None) -> dict:
    """POST request to internal SCADA API."""
    async with httpx.AsyncClient(base_url=_API_BASE, timeout=15) as client:
        resp = await client.post(path, json=data or {})
        resp.raise_for_status()
        return resp.json()


async def execute_tool(name: str, args: dict) -> dict:
    """Execute a SCADA tool and return result."""
    try:
        if name == "get_sites":
            return await _api_get("/api/sites")

        elif name == "get_devices":
            params = {}
            if args.get("site_id"):
                params["site_id"] = args["site_id"]
            return await _api_get("/api/devices", params)

        elif name == "get_metrics":
            device_id = args["device_id"]
            data = await _api_get("/api/metrics", {"device_id": device_id})
            result = data[0] if isinstance(data, list) and data else data
            # Add hint for ATS to prevent LLM from confusing fields
            if isinstance(result, dict) and result.get("device_type") == "ats":
                result["_Ð¿Ð¾Ð´ÑÐºÐ°Ð·ÐºÐ°"] = (
                    "mains_total_p â€” Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚ÑŒ Ð¾Ñ‚ Ð²Ð½ÐµÑˆÐ½ÐµÐ¹ ÑÐµÑ‚Ð¸ (ÐºÐ’Ñ‚). "
                    "Ð”Ð»Ñ Ð¡Ð£ÐœÐœÐÐ ÐÐžÐ™ Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚Ð¸ Ð¾Ð±ÑŠÐµÐºÑ‚Ð° Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ get_system_summary â†’ site_total_power_kw. "
                    "ÐÐ• Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹ load_total_p Ð¸Ð»Ð¸ busbar_p Ð´Ð»Ñ Ñ€Ð°ÑÑ‡Ñ‘Ñ‚Ð° Ð¾Ð±Ñ‰ÐµÐ³Ð¾ Ð¿Ð¾Ñ‚Ñ€ÐµÐ±Ð»ÐµÐ½Ð¸Ñ."
                )
            return result

        elif name == "get_all_metrics":
            return await _api_get("/api/metrics")

        elif name == "get_alarms":
            params = {}
            if args.get("device_id"):
                params["device_id"] = args["device_id"]
            alarms = await _api_get("/api/history/alarms/active", params)
            # If site_id provided, filter alarms to devices of that site
            site_id = args.get("site_id")
            site_device_ids = None
            if site_id:
                try:
                    devices = await _api_get("/api/devices", {"site_id": site_id})
                    site_device_ids = {d["id"] for d in devices} if isinstance(devices, list) else None
                except Exception:
                    site_device_ids = None
                if site_device_ids is not None and isinstance(alarms, list):
                    alarms = [a for a in alarms if a.get("device_id") in site_device_ids]
            # Enrich with device names, status and duration for LLM
            if isinstance(alarms, list) and alarms:
                try:
                    if site_device_ids is None:
                        devices = await _api_get("/api/devices")
                    dev_names = {d["id"]: d["name"] for d in devices} if isinstance(devices, list) else {}
                except Exception:
                    dev_names = {}
                for a in alarms:
                    a["device_name"] = dev_names.get(a.get("device_id"), f"Ð£ÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð¾ #{a.get('device_id')}")
                    a["status"] = "âš ï¸ ÐÐšÐ¢Ð˜Ð’ÐÐ Ð¡Ð•Ð™Ð§ÐÐ¡"
                    a["duration"] = _calc_alarm_duration(a.get("occurred_at"))

            # ALWAYS check gen_status â€” a stopped generator without alarm is still a problem!
            result = {"alarms": alarms if isinstance(alarms, list) else []}
            try:
                # Reuse devices already fetched for site filtering, or fetch minimal set
                if not site_id and not args.get("device_id"):
                    check_devs = await _api_get("/api/devices")
                elif site_id and site_device_ids is not None:
                    check_devs = [{"id": did} for did in site_device_ids]
                    # Enrich with names and types
                    try:
                        devs_full = await _api_get("/api/devices", {"site_id": site_id})
                        check_devs = devs_full if isinstance(devs_full, list) else check_devs
                    except Exception:
                        pass
                else:
                    check_devs = []

                # Only check generators (skip ATS), fetch metrics only for site
                gens = [d for d in check_devs if d.get("device_type", "generator") != "ats"] if isinstance(check_devs, list) else []
                if gens:
                    m_params = {"site_id": site_id} if site_id else {}
                    site_metrics = await _api_get("/api/metrics", m_params)
                    m_map = {m["device_id"]: m for m in site_metrics} if isinstance(site_metrics, list) else {}
                    stopped_gens = []
                    for dev in gens:
                        m = m_map.get(dev["id"], {})
                        gs = m.get("gen_status")
                        dname = dev.get("name") or f"#{dev['id']}"
                        if not m.get("online", False):
                            stopped_gens.append(f"ðŸš¨ {dname} â€” ÐÐ•Ð¢ Ð¡Ð’Ð¯Ð—Ð˜")
                        elif gs is not None and gs != 9:
                            label = GEN_STATUS_LABELS.get(gs, f"status={gs}")
                            stopped_gens.append(
                                f"ðŸš¨ {dname} â€” ÐÐ• Ð ÐÐ‘ÐžÐ¢ÐÐ•Ð¢ "
                                f"(gen_status={gs}: {label}, power={m.get('power_total', 0)} ÐºÐ’Ñ‚)"
                            )
                    if stopped_gens:
                        result["STOPPED_GENERATORS"] = stopped_gens
                        result["_Ð˜ÐÐ¡Ð¢Ð Ð£ÐšÐ¦Ð˜Ð¯"] = (
                            "Ð•Ð¡Ð¢Ð¬ ÐÐ•Ð ÐÐ‘ÐžÐ¢ÐÐ®Ð©Ð˜Ð• Ð“Ð•ÐÐ•Ð ÐÐ¢ÐžÐ Ð«! "
                            "Ð—ÐÐŸÐ Ð•Ð©Ð•ÐÐž Ð³Ð¾Ð²Ð¾Ñ€Ð¸Ñ‚ÑŒ 'Ð¾ÑˆÐ¸Ð±Ð¾Ðº Ð½ÐµÑ‚' Ð¸Ð»Ð¸ 'Ð²ÑÑ‘ Ð² Ð¿Ð¾Ñ€ÑÐ´ÐºÐµ'. "
                            "ÐžÐ‘Ð¯Ð—ÐÐ¢Ð•Ð›Ð¬ÐÐž ÑÐ¾Ð¾Ð±Ñ‰Ð¸ Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ñƒ Ð¾ ÐºÐ°Ð¶Ð´Ð¾Ð¼ Ð¾ÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð½Ð¾Ð¼ Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ðµ!"
                        )
            except Exception as e:
                logger.warning("Gen status check in get_alarms failed: %s", e)

            # If simple alarm list with no extra info, return flat list for backward compat
            if not result.get("STOPPED_GENERATORS"):
                return result["alarms"]
            return result

        elif name == "get_alarm_history":
            params = {"limit": args.get("limit", 50)}
            if args.get("device_id"):
                params["device_id"] = args["device_id"]
            if args.get("last_hours"):
                params["last_hours"] = args["last_hours"]
            alarms = await _api_get("/api/history/alarms", params)
            # Enrich with device names and duration for active alarms
            if isinstance(alarms, list) and alarms:
                try:
                    devices = await _api_get("/api/devices")
                    dev_names = {d["id"]: d["name"] for d in devices} if isinstance(devices, list) else {}
                except Exception:
                    dev_names = {}
                for a in alarms:
                    a["device_name"] = dev_names.get(a.get("device_id"), f"Ð£ÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð¾ #{a.get('device_id')}")
                    if a.get("is_active"):
                        a["status"] = "âš ï¸ ÐÐšÐ¢Ð˜Ð’ÐÐ Ð¡Ð•Ð™Ð§ÐÐ¡"
                        a["duration"] = _calc_alarm_duration(a.get("occurred_at"))
            return alarms

        elif name == "get_maintenance_status":
            device_id = args["device_id"]
            return await _api_get(f"/api/devices/{device_id}/maintenance")

        elif name == "get_maintenance_alerts":
            params = {}
            if args.get("device_id"):
                params["device_id"] = args["device_id"]
            return await _api_get("/api/alerts", params)

        elif name == "get_history":
            device_id = args["device_id"]
            fields = args.get("fields")
            if not fields:
                # Auto-detect device type to choose correct default fields
                try:
                    devs = await _api_get("/api/metrics", {"device_id": device_id})
                    d = devs[0] if isinstance(devs, list) and devs else {}
                    dt = d.get("device_type", "generator")
                except Exception:
                    dt = "generator"
                fields = "mains_total_p,busbar_p,load_total_p" if dt == "ats" else "power_total"
            params = {
                "last_hours": args.get("last_hours", 24),
                "fields": fields,
                "limit": 100,
            }
            return await _api_get(f"/api/history/metrics/{device_id}", params)

        elif name == "get_system_summary":
            return await _build_system_summary()

        elif name == "send_command":
            return await _execute_command(args["device_id"], args["command"])

        elif name == "set_power_limit":
            return await _execute_power_limit(
                args["device_id"],
                args.get("p_percent"),
                args.get("q_percent"),
                args.get("load_mode"),
            )

        elif name == "get_energy_report":
            return await _build_energy_report(
                args.get("site_id"),
                args.get("last_hours", 168),
            )

        elif name == "search_knowledge":
            return await _search_knowledge_base(
                args["query"],
                args.get("category"),
            )

        elif name == "analyze_incident":
            return await _analyze_incident(
                args.get("site_id"),
                args.get("device_id"),
                args.get("last_hours", 24),
            )

        else:
            return {"error": f"ÐÐµÐ¸Ð·Ð²ÐµÑÑ‚Ð½Ñ‹Ð¹ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚: {name}"}

    except httpx.HTTPStatusError as e:
        logger.error("Tool %s HTTP error: %s", name, e)
        return {"error": f"ÐžÑˆÐ¸Ð±ÐºÐ° API ({e.response.status_code}): {e.response.text[:200]}"}
    except Exception as e:
        logger.error("Tool %s error: %s", name, e, exc_info=True)
        return {"error": f"ÐžÑˆÐ¸Ð±ÐºÐ°: {str(e)}"}


def _calc_alarm_duration(occurred_at) -> str:
    """Ð’Ñ‹Ñ‡Ð¸ÑÐ»Ð¸Ñ‚ÑŒ Ñ‡ÐµÐ»Ð¾Ð²ÐµÐºÐ¾Ñ‡Ð¸Ñ‚Ð°ÐµÐ¼ÑƒÑŽ Ð´Ð»Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚ÑŒ Ð°Ð²Ð°Ñ€Ð¸Ð¸."""
    if not occurred_at:
        return "Ð½ÐµÐ¸Ð·Ð²ÐµÑÑ‚Ð½Ð¾"
    try:
        if isinstance(occurred_at, str):
            ts = datetime.fromisoformat(occurred_at.replace("Z", "").replace("+00:00", ""))
        else:
            ts = occurred_at
        delta = datetime.utcnow() - ts
        days = delta.days
        hours = delta.seconds // 3600
        mins = (delta.seconds % 3600) // 60
        parts = []
        if days > 0:
            parts.append(f"{days} Ð´Ð½.")
        if hours > 0:
            parts.append(f"{hours} Ñ‡.")
        if mins > 0 and days == 0:
            parts.append(f"{mins} Ð¼Ð¸Ð½.")
        return " ".join(parts) if parts else "Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ñ‡Ñ‚Ð¾"
    except Exception:
        return "Ð½ÐµÐ¸Ð·Ð²ÐµÑÑ‚Ð½Ð¾"


async def _build_system_summary() -> dict:
    """Build comprehensive system summary."""
    summary = {"sites": [], "total_devices": 0, "active_alarms": 0}

    try:
        sites = await _api_get("/api/sites")
        all_metrics = await _api_get("/api/metrics")
        alarms = await _api_get("/api/history/alarms/active")
        alert_summary = await _api_get("/api/alerts/summary")

        metrics_by_device = {}
        if isinstance(all_metrics, list):
            for m in all_metrics:
                did = m.get("device_id")
                if did:
                    metrics_by_device[did] = m

        for site in (sites if isinstance(sites, list) else []):
            devices = await _api_get("/api/devices", {"site_id": site["id"]})
            device_list = []
            site_gen_p = 0.0   # sum of running generators' power
            site_mains_p = 0.0  # mains power from ATS
            site_mains_q = 0.0  # mains reactive from ATS
            site_gen_q = 0.0   # generators reactive (busbar_q)
            site_running_gens = 0
            for dev in (devices if isinstance(devices, list) else []):
                m = metrics_by_device.get(dev["id"], {})
                dev_type = dev.get("device_type", "")
                if dev_type == "ats":
                    power_kw = m.get("mains_total_p") or 0
                    voltage_v = m.get("mains_uab")
                    site_mains_p = power_kw
                    site_mains_q = m.get("mains_total_q") or 0
                    site_gen_q = m.get("busbar_q") or 0
                else:
                    power_kw = m.get("power_total") or 0
                    voltage_v = m.get("gen_uab")
                    # Count running generators (gen_status=9 = Ñ€Ð°Ð±Ð¾Ñ‚Ð°)
                    if m.get("online") and m.get("gen_status") == 9:
                        site_gen_p += power_kw
                        site_running_gens += 1
                gs = m.get("gen_status")
                dev_info = {
                    "id": dev["id"],
                    "name": dev["name"],
                    "type": dev_type,
                    "online": m.get("online", False),
                    "power_kw": round(power_kw, 1) if power_kw else 0,
                    "voltage_v": voltage_v,
                    "coolant_temp": m.get("coolant_temp"),
                    "engine_speed": m.get("engine_speed"),
                    "run_hours": m.get("run_hours"),
                    "fuel_level": m.get("fuel_level"),
                    "gen_status": gs,
                }
                # Add human-readable gen_status and running flag for generators
                if dev_type != "ats":
                    dev_info["gen_status_label"] = GEN_STATUS_LABELS.get(gs, f"ÐÐµÐ¸Ð·Ð²ÐµÑÑ‚Ð½Ð¾ ({gs})")
                    dev_info["is_running"] = (gs == 9 and m.get("online", False))
                    if not dev_info["is_running"]:
                        if not m.get("online", False):
                            dev_info["status_warning"] = "âš  ÐÐ•Ð¢ Ð¡Ð’Ð¯Ð—Ð˜ â€” Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð½Ðµ Ð¿Ð¾ÑÑ‚ÑƒÐ¿Ð°ÑŽÑ‚!"
                        elif gs == 0:
                            dev_info["status_warning"] = "âš  ÐžÐ¡Ð¢ÐÐÐžÐ’Ð›Ð•Ð â€” Ð´Ð²Ð¸Ð³Ð°Ñ‚ÐµÐ»ÑŒ Ð½Ðµ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚"
                        elif gs == 8:
                            dev_info["status_warning"] = "ðŸš¨ ÐÐ’ÐÐ Ð˜Ð™ÐÐ«Ð™ Ð¡Ð¢ÐžÐŸ â€” Ñ‚Ñ€ÐµÐ±ÑƒÐµÑ‚ÑÑ Ð²Ð¼ÐµÑˆÐ°Ñ‚ÐµÐ»ÑŒÑÑ‚Ð²Ð¾!"
                        elif gs is not None and gs != 9:
                            dev_info["status_warning"] = f"âš  ÐÐ• Ð² Ñ€Ð°Ð±Ð¾Ñ‡ÐµÐ¼ Ñ€ÐµÐ¶Ð¸Ð¼Ðµ (ÑÑ‚Ð°Ñ‚ÑƒÑ: {GEN_STATUS_LABELS.get(gs, gs)})"
                # ATS-specific breakdown
                if dev_type == "ats":
                    dev_info["mains_p_kw"] = m.get("mains_total_p")
                    dev_info["busbar_p_kw"] = m.get("busbar_p")
                device_list.append(dev_info)
                summary["total_devices"] += 1

            # Count total generators and stopped ones
            total_gens = sum(1 for d in device_list if d.get("type") != "ats")
            stopped_gens = sum(1 for d in device_list if d.get("type") != "ats" and not d.get("is_running"))
            offline_devices = sum(1 for d in device_list if not d.get("online"))

            # Site-level power summary (same formula as frontend)
            site_total_p = round(site_gen_p + site_mains_p, 1)
            site_total_q = round(site_gen_q + site_mains_q, 1)
            site_data = {
                "id": site["id"],
                "name": site["name"],
                "code": site.get("code", ""),
                "devices": device_list,
                "site_total_power_kw": site_total_p,
                "site_total_reactive_kvar": site_total_q,
                "site_mains_power_kw": round(site_mains_p, 1),
                "site_generators_power_kw": round(site_gen_p, 1),
                "site_running_generators": site_running_gens,
                "site_total_generators": total_gens,
                "site_stopped_generators": stopped_gens,
            }
            if stopped_gens > 0:
                site_data["site_warning"] = f"âš  {stopped_gens} Ð¸Ð· {total_gens} Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð¾Ð² ÐÐ• Ð ÐÐ‘ÐžÐ¢ÐÐ®Ð¢!"
            if offline_devices > 0:
                site_data["site_offline_warning"] = f"âš  {offline_devices} ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð² Ð±ÐµÐ· ÑÐ²ÑÐ·Ð¸!"
            summary["sites"].append(site_data)

        # Build device name lookup for alarm enrichment
        device_names = {}
        for site_data in summary["sites"]:
            for dev in site_data.get("devices", []):
                device_names[dev["id"]] = dev["name"]

        # Active alarm details with status and duration
        if isinstance(alarms, list) and alarms:
            summary["active_alarms"] = len(alarms)
            summary["active_alarm_details"] = [
                {
                    "device_id": a["device_id"],
                    "device_name": device_names.get(a["device_id"], f"Ð£ÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð¾ #{a['device_id']}"),
                    "alarm_code": a["alarm_code"],
                    "severity": a["severity"],
                    "message": a["message"],
                    "status": "âš ï¸ ÐÐšÐ¢Ð˜Ð’ÐÐ Ð¡Ð•Ð™Ð§ÐÐ¡",
                    "duration": _calc_alarm_duration(a.get("occurred_at")),
                }
                for a in alarms
            ]
        else:
            summary["active_alarms"] = 0
            summary["active_alarm_details"] = []

        summary["maintenance_alerts"] = alert_summary if isinstance(alert_summary, dict) else {}

        # Build CRITICAL_WARNINGS â€” impossible-to-ignore list for LLM
        critical_warnings = []
        for site_data in summary["sites"]:
            for dev in site_data.get("devices", []):
                if dev.get("type") == "ats":
                    continue
                if dev.get("status_warning"):
                    critical_warnings.append(
                        f"ðŸš¨ {site_data['name']} â†’ {dev['name']}: {dev['status_warning']} "
                        f"(gen_status={dev.get('gen_status')}, power={dev.get('power_kw')} ÐºÐ’Ñ‚)"
                    )
                if not dev.get("online"):
                    critical_warnings.append(
                        f"ðŸš¨ {site_data['name']} â†’ {dev['name']}: ÐŸÐžÐ¢Ð•Ð Ð¯ Ð¡Ð’Ð¯Ð—Ð˜ â€” Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð½Ðµ Ð¿Ð¾ÑÑ‚ÑƒÐ¿Ð°ÑŽÑ‚!"
                    )
            if site_data.get("site_warning"):
                critical_warnings.append(f"âš  ÐžÐ‘ÐªÐ•ÐšÐ¢ {site_data['name']}: {site_data['site_warning']}")

        if isinstance(alarms, list) and alarms:
            for a in alarms:
                dn = device_names.get(a["device_id"], f"#{a['device_id']}")
                critical_warnings.append(
                    f"ðŸš¨ ÐÐ’ÐÐ Ð˜Ð¯: {dn} â€” {a.get('alarm_code')} ({a.get('message', '')})"
                )

        if critical_warnings:
            summary["CRITICAL_WARNINGS"] = critical_warnings
            summary["_Ð˜ÐÐ¡Ð¢Ð Ð£ÐšÐ¦Ð˜Ð¯"] = (
                "Ð’ÐÐ˜ÐœÐÐÐ˜Ð•! Ð•ÑÑ‚ÑŒ ÐºÑ€Ð¸Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸Ðµ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ñ‹ (ÑÐ¼. CRITICAL_WARNINGS). "
                "Ð—ÐÐŸÐ Ð•Ð©Ð•ÐÐž Ð³Ð¾Ð²Ð¾Ñ€Ð¸Ñ‚ÑŒ 'Ð²ÑÑ‘ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚ Ð½Ð¾Ñ€Ð¼Ð°Ð»ÑŒÐ½Ð¾' Ð¸Ð»Ð¸ 'Ð² ÑˆÑ‚Ð°Ñ‚Ð½Ð¾Ð¼ Ñ€ÐµÐ¶Ð¸Ð¼Ðµ'. "
                "ÐžÐ‘Ð¯Ð—ÐÐ¢Ð•Ð›Ð¬ÐÐž ÑÐ¾Ð¾Ð±Ñ‰Ð¸ Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ñƒ Ð¾ ÐšÐÐ–Ð”ÐžÐ™ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ðµ Ð¸Ð· ÑÑ‚Ð¾Ð³Ð¾ ÑÐ¿Ð¸ÑÐºÐ°!"
            )
        else:
            summary["system_status"] = "âœ… Ð’ÑÐµ ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð° Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÑŽÑ‚ Ð² ÑˆÑ‚Ð°Ñ‚Ð½Ð¾Ð¼ Ñ€ÐµÐ¶Ð¸Ð¼Ðµ"

    except Exception as e:
        logger.error("Error building system summary: %s", e)
        summary["error"] = str(e)

    return summary


async def _build_energy_report(site_id: int | None, last_hours: int) -> dict:
    """Build energy production/consumption report for a period.

    Calculates delta of energy_kwh counters between start and end of period.
    Also reports average power (power_total for generators, load_total_p for ATS).
    """
    report = {"period_hours": last_hours, "devices": [], "totals": {}}

    try:
        # Get all devices (optionally filtered by site)
        params = {}
        if site_id:
            params["site_id"] = site_id
        sites = await _api_get("/api/sites")
        all_devices = []
        for site in (sites if isinstance(sites, list) else []):
            if site_id and site["id"] != site_id:
                continue
            devs = await _api_get("/api/devices", {"site_id": site["id"]})
            for d in (devs if isinstance(devs, list) else []):
                d["_site_name"] = site["name"]
                all_devices.append(d)

        total_gen_kwh = 0
        total_mains_kwh = 0

        for dev in all_devices:
            did = dev["id"]
            dtype = dev.get("device_type", "generator")
            dname = dev.get("name", f"#{did}")
            site_name = dev.get("_site_name", "")

            # Get power history for average calculation (sampled, limit OK)
            power_field = "power_total" if dtype == "generator" else "mains_total_p"
            hist = await _api_get(f"/api/history/metrics/{did}", {
                "last_hours": last_hours,
                "fields": power_field,
                "limit": 3000,
            })

            if not isinstance(hist, list) or len(hist) < 2:
                report["devices"].append({
                    "device_id": did,
                    "name": dname,
                    "site": site_name,
                    "type": dtype,
                    "note": "ÐÐµÐ´Ð¾ÑÑ‚Ð°Ñ‚Ð¾Ñ‡Ð½Ð¾ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð·Ð° Ð¿ÐµÑ€Ð¸Ð¾Ð´",
                })
                continue

            # Collect power readings for average
            powers = []
            for pt in hist:
                p = pt.get(power_field)
                if p is not None and p > 0:
                    powers.append(p)

            # Energy delta â€” robust helper with null handling
            ed = await _get_energy_delta(did, last_hours, is_generator=(dtype == "generator"))
            energy_delta = ed["energy_delta"]
            run_delta = ed["rh_delta"]

            avg_power = round(sum(powers) / len(powers), 1) if powers else None
            max_power = round(max(powers), 1) if powers else None

            dev_report = {
                "device_id": did,
                "name": dname,
                "site": site_name,
                "type": "Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€" if dtype == "generator" else "Ð¨ÐŸÐ ",
                "energy_kwh": energy_delta,
                "avg_power_kw": avg_power,
                "max_power_kw": max_power,
                "data_points": len(hist),
            }
            if run_delta is not None:
                dev_report["run_hours_delta"] = run_delta
            if energy_delta is None and avg_power:
                # Estimate from average power * hours
                estimated = round(avg_power * last_hours, 0)
                dev_report["estimated_kwh"] = estimated
                dev_report["note"] = "Ð¡Ñ‡Ñ‘Ñ‚Ñ‡Ð¸Ðº energy_kwh Ð½ÐµÐ´Ð¾ÑÑ‚ÑƒÐ¿ÐµÐ½, Ð¾Ñ†ÐµÐ½ÐºÐ° Ð¿Ð¾ ÑÑ€ÐµÐ´Ð½ÐµÐ¹ Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚Ð¸"

            if dtype == "generator" and energy_delta is not None:
                total_gen_kwh += energy_delta
            elif dtype == "ats" and energy_delta is not None:
                total_mains_kwh += energy_delta

            report["devices"].append(dev_report)

        report["totals"] = {
            "generators_kwh": round(total_gen_kwh, 1),
            "note": f"Ð¡ÑƒÐ¼Ð¼Ð°Ñ€Ð½Ð°Ñ Ð²Ñ‹Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð¾Ð² Ð·Ð° {last_hours} Ñ‡Ð°ÑÐ¾Ð²",
        }
        if total_mains_kwh:
            report["totals"]["mains_kwh"] = round(total_mains_kwh, 1)

    except Exception as e:
        logger.error("Error building energy report: %s", e, exc_info=True)
        report["error"] = str(e)

    return report


async def _execute_command(device_id: int, command: str) -> dict:
    """Execute a command on a device.

    Special handling for 'reset' â€” uses multi-strategy endpoint
    (/api/commands/reset/{id}) which does Stop-in-Stop + fallbacks.
    Other commands use raw FC05 coil writes.
    """
    # Reset uses dedicated multi-strategy endpoint (proven working)
    if command == "reset":
        result = await _api_post(f"/api/commands/reset/{device_id}")
        return result

    if command not in COMMAND_ADDRESSES:
        return {"error": f"ÐÐµÐ¸Ð·Ð²ÐµÑÑ‚Ð½Ð°Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð°: {command}"}

    fc, address, value = COMMAND_ADDRESSES[command]
    result = await _api_post("/api/commands", {
        "device_id": device_id,
        "function_code": fc,
        "address": address,
        "value": value,
    })
    return result


async def _execute_power_limit(
    device_id: int,
    p_percent: Optional[float] = None,
    q_percent: Optional[float] = None,
    load_mode: Optional[int] = None,
) -> dict:
    """Set power limit on a device."""
    # Read current values first
    current = await _api_get(f"/api/devices/{device_id}/power-limit")

    p_raw = int(p_percent * 10) if p_percent is not None else (current.get("config_p_raw") or 1000)
    q_raw = int(q_percent * 10) if q_percent is not None else (current.get("config_q_raw") or 1000)

    body = {"p_raw": p_raw, "q_raw": q_raw}
    if load_mode is not None:
        body["load_mode"] = int(load_mode)

    result = await _api_post(f"/api/devices/{device_id}/power-limit", body)
    return result


async def _analyze_incident(
    site_id: int | None,
    device_id: int | None,
    last_hours: int,
) -> dict:
    """Analyze downtime/incident: alarms timeline, metric snapshots at alarm times, power drops, energy losses."""
    report = {
        "period_hours": last_hours,
        "alarms_timeline": [],
        "devices_analysis": [],
        "summary": {},
    }

    try:
        # 1. Get all alarm events for the period
        alarm_params = {"last_hours": last_hours, "limit": 200}
        if device_id:
            alarm_params["device_id"] = device_id
        alarms = await _api_get("/api/history/alarms", alarm_params)

        # Get device names
        devices = await _api_get("/api/devices")
        dev_map = {}
        if isinstance(devices, list):
            for d in devices:
                dev_map[d["id"]] = d

        # Filter by site if needed
        if site_id and not device_id:
            site_dev_ids = {d["id"] for d in devices if d.get("site_id") == site_id}
        else:
            site_dev_ids = None

        # 2. Build alarm timeline (chronological)
        if isinstance(alarms, list):
            for a in alarms:
                did = a.get("device_id")
                if site_dev_ids and did not in site_dev_ids:
                    continue
                dev_info = dev_map.get(did, {})
                entry = {
                    "time": a.get("occurred_at"),
                    "cleared_at": a.get("cleared_at"),
                    "device_id": did,
                    "device_name": dev_info.get("name", f"#{did}"),
                    "device_type": dev_info.get("device_type", "?"),
                    "alarm_code": a.get("alarm_code"),
                    "severity": a.get("severity"),
                    "message": a.get("message"),
                    "is_active": a.get("is_active", False),
                    "duration": _calc_alarm_duration(a.get("occurred_at")) if a.get("is_active") else None,
                }
                if a.get("cleared_at") and a.get("occurred_at"):
                    try:
                        t0 = datetime.fromisoformat(str(a["occurred_at"]).replace("Z", "").replace("+00:00", ""))
                        t1 = datetime.fromisoformat(str(a["cleared_at"]).replace("Z", "").replace("+00:00", ""))
                        entry["duration_minutes"] = round((t1 - t0).total_seconds() / 60, 1)
                    except Exception:
                        pass
                report["alarms_timeline"].append(entry)

        # Sort by time
        report["alarms_timeline"].sort(key=lambda x: x.get("time") or "")

        # 2.5. Get METRIC SNAPSHOTS at alarm times for root cause analysis
        # For each alarm event on a generator, fetch metrics around the alarm time
        _all_fields_gen = "power_total,coolant_temp,oil_pressure,engine_speed,fuel_level,gen_uab,frequency"
        alarm_metrics = []  # List of {alarm_time, device, metrics_before, metrics_at, metrics_after}
        processed_alarm_times = set()  # Avoid duplicate fetches for same device+time

        for alarm in report["alarms_timeline"]:
            acode = alarm.get("alarm_code", "")
            did = alarm.get("device_id")
            atime = alarm.get("time")
            dtype = alarm.get("device_type", "")
            if not did or not atime or dtype != "generator":
                continue
            if acode == "CONN_LOST":
                continue
            # Deduplicate: same device within 2 minutes
            dedup_key = f"{did}_{atime[:16]}"
            if dedup_key in processed_alarm_times:
                continue
            processed_alarm_times.add(dedup_key)

            try:
                # Get metrics Â±5 minutes around alarm time
                from datetime import timedelta
                alarm_dt = datetime.fromisoformat(str(atime).replace("Z", "").replace("+00:00", ""))
                t_from = (alarm_dt - timedelta(minutes=5)).isoformat()
                t_to = (alarm_dt + timedelta(minutes=5)).isoformat()

                snap = await _api_get(f"/api/history/metrics/{did}", {
                    "fields": _all_fields_gen,
                    "start": t_from,
                    "end": t_to,
                    "limit": 200,
                })

                if isinstance(snap, list) and snap:
                    # Split into before/at/after alarm time
                    before = []
                    after = []
                    for pt in snap:
                        pts = pt.get("timestamp", "")
                        if pts < atime:
                            before.append(pt)
                        else:
                            after.append(pt)

                    # Get key metric values: last before alarm, first after alarm
                    metrics_before = before[-1] if before else None
                    metrics_at = after[0] if after else (before[-1] if before else None)

                    # Build compact snapshot
                    snapshot = {
                        "alarm_time": atime,
                        "alarm_code": acode,
                        "alarm_message": alarm.get("message", ""),
                        "device_id": did,
                        "device_name": alarm.get("device_name", ""),
                    }

                    if metrics_before:
                        snapshot["metrics_before_alarm"] = {
                            "timestamp": metrics_before.get("timestamp"),
                            "power_kw": _rnd(metrics_before.get("power_total")),
                            "coolant_temp_C": _rnd(metrics_before.get("coolant_temp")),
                            "oil_pressure_kPa": _rnd(metrics_before.get("oil_pressure")),
                            "engine_speed_rpm": _rnd(metrics_before.get("engine_speed")),
                            "voltage_V": _rnd(metrics_before.get("gen_uab")),
                            "frequency_Hz": _rnd(metrics_before.get("frequency")),
                            "fuel_level_pct": _rnd(metrics_before.get("fuel_level")),
                        }

                    if metrics_at:
                        snapshot["metrics_at_alarm"] = {
                            "timestamp": metrics_at.get("timestamp"),
                            "power_kw": _rnd(metrics_at.get("power_total")),
                            "coolant_temp_C": _rnd(metrics_at.get("coolant_temp")),
                            "oil_pressure_kPa": _rnd(metrics_at.get("oil_pressure")),
                            "engine_speed_rpm": _rnd(metrics_at.get("engine_speed")),
                            "voltage_V": _rnd(metrics_at.get("gen_uab")),
                            "frequency_Hz": _rnd(metrics_at.get("frequency")),
                            "fuel_level_pct": _rnd(metrics_at.get("fuel_level")),
                        }

                    # Trend: min/max of key params in the Â±5 min window
                    all_powers = [pt.get("power_total") for pt in snap if pt.get("power_total") is not None]
                    all_temps = [pt.get("coolant_temp") for pt in snap if pt.get("coolant_temp") is not None]
                    all_oil = [pt.get("oil_pressure") for pt in snap if pt.get("oil_pressure") is not None]
                    all_speed = [pt.get("engine_speed") for pt in snap if pt.get("engine_speed") is not None]

                    snapshot["trend_5min"] = {}
                    if all_powers:
                        snapshot["trend_5min"]["power_kw"] = {"min": _rnd(min(all_powers)), "max": _rnd(max(all_powers))}
                    if all_temps:
                        snapshot["trend_5min"]["coolant_temp_C"] = {"min": _rnd(min(all_temps)), "max": _rnd(max(all_temps))}
                    if all_oil:
                        snapshot["trend_5min"]["oil_pressure_kPa"] = {"min": _rnd(min(all_oil)), "max": _rnd(max(all_oil))}
                    if all_speed:
                        snapshot["trend_5min"]["engine_speed_rpm"] = {"min": _rnd(min(all_speed)), "max": _rnd(max(all_speed))}

                    alarm_metrics.append(snapshot)

            except Exception as e:
                logger.warning("Failed to get metric snapshot for alarm at %s: %s", atime, e)

        if alarm_metrics:
            report["alarm_metric_snapshots"] = alarm_metrics

        # 2.6. Auto-search knowledge base for each unique alarm type
        _ALARM_KB_QUERIES = {
            "SHUTDOWN": [
                "alarm shutdown trip over power over current",
                "coolant temperature oil pressure over speed",
                "reverse power under frequency over voltage",
            ],
            "COMMON": [
                "alarm warning common fault",
                "alarm shutdown trip protection",
            ],
            "WARNING": [
                "warning alarm maintenance service",
                "high temperature low pressure sensor",
            ],
            "BLOCK": [
                "alarm block interlock start failure",
                "alarm shutdown trip protection",
            ],
            "TRIP_STOP": [
                "emergency stop trip safety",
                "alarm shutdown trip protection",
            ],
        }

        kb_context = {}
        unique_alarm_codes = set()
        for a in report["alarms_timeline"]:
            code = a.get("alarm_code", "")
            if code and code != "CONN_LOST":
                unique_alarm_codes.add(code)

        for code in unique_alarm_codes:
            queries = _ALARM_KB_QUERIES.get(code, [f"{code} alarm protection"])
            all_results = []
            seen_ids = set()

            for q in queries:
                try:
                    results = await _api_get("/api/ai/knowledge/search", {"q": q, "limit": 5})
                    if isinstance(results, list):
                        for r in results:
                            rid = r.get("id")
                            if rid and rid not in seen_ids:
                                seen_ids.add(rid)
                                all_results.append({
                                    "title": r.get("title", ""),
                                    "content": r.get("content", "")[:1500],
                                    "source": r.get("source_filename", ""),
                                })
                except Exception as e:
                    logger.warning("KB search for alarm %s query '%s' failed: %s", code, q, e)

            if all_results:
                kb_context[code] = all_results[:5]

        if kb_context:
            report["knowledge_base_context"] = kb_context

        # 2.7. Fetch scada_events (journal) for state transitions context
        # These events explain WHY generators were idle: GEN_STATUS transitions, MODE_CHANGE, MAINS, etc.
        try:
            ev_params = {"last_hours": last_hours, "limit": 500}
            if device_id:
                ev_params["device_id"] = device_id
            elif site_id:
                ev_params["site_id"] = site_id
            journal_events = await _api_get("/api/events", ev_params)
            if isinstance(journal_events, list) and journal_events:
                # Group journal events by device_id
                _journal_by_device: dict[int, list] = {}
                for jev in journal_events:
                    did_j = jev.get("device_id")
                    if did_j is not None:
                        _journal_by_device.setdefault(did_j, []).append({
                            "time": jev.get("created_at"),
                            "category": jev.get("category"),
                            "event_code": jev.get("event_code"),
                            "message": jev.get("message"),
                            "old_value": jev.get("old_value"),
                            "new_value": jev.get("new_value"),
                        })
                report["_journal_by_device"] = _journal_by_device
                report["journal_events_total"] = len(journal_events)
        except Exception as e:
            logger.warning("Failed to fetch journal events for incident analysis: %s", e)

        # 3. Analyze each device's metrics for the full period
        target_devices = []
        if device_id:
            if device_id in dev_map:
                target_devices = [dev_map[device_id]]
        elif site_dev_ids:
            target_devices = [dev_map[did] for did in site_dev_ids if did in dev_map]
        else:
            target_devices = list(dev_map.values())

        total_downtime_minutes = 0
        total_energy_lost_kwh = 0

        for dev in target_devices:
            did = dev["id"]
            dtype = dev.get("device_type", "generator")
            dname = dev.get("name", f"#{did}")

            # Get full metric history for the period (extended fields for generators)
            if dtype == "generator":
                fields = "power_total,coolant_temp,oil_pressure,engine_speed,gen_uab,frequency,energy_kwh,run_hours"
            else:
                fields = "mains_total_p,busbar_p,mains_uab,energy_kwh"

            hist = await _api_get(f"/api/history/metrics/{did}", {
                "last_hours": last_hours,
                "fields": fields,
                "limit": 3000,
            })

            if not isinstance(hist, list) or len(hist) < 2:
                report["devices_analysis"].append({
                    "device_id": did,
                    "name": dname,
                    "type": dtype,
                    "note": "ÐÐµÐ´Ð¾ÑÑ‚Ð°Ñ‚Ð¾Ñ‡Ð½Ð¾ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð·Ð° Ð¿ÐµÑ€Ð¸Ð¾Ð´",
                })
                continue

            # Analyze power data
            power_field = "power_total" if dtype == "generator" else "mains_total_p"
            powers = []
            zero_runs = []
            current_zero_start = None

            for pt in hist:
                p = pt.get(power_field)
                ts = pt.get("timestamp") or pt.get("bucket")
                if p is not None:
                    powers.append({"ts": ts, "p": float(p)})
                    if float(p) < 1.0:
                        if current_zero_start is None:
                            current_zero_start = ts
                    else:
                        if current_zero_start is not None:
                            zero_runs.append({"from": current_zero_start, "to": ts})
                            current_zero_start = None

            if current_zero_start is not None:
                zero_runs.append({"from": current_zero_start, "to": "now"})

            # Energy delta â€” robust helper with null handling
            ed = await _get_energy_delta(did, last_hours, is_generator=(dtype == "generator"))
            energy_delta = ed["energy_delta"]
            rh_delta = ed["rh_delta"]

            # Downtime calculation
            dev_downtime_min = 0
            for zr in zero_runs:
                try:
                    t0 = datetime.fromisoformat(str(zr["from"]).replace("Z", "").replace("+00:00", ""))
                    if zr["to"] == "now":
                        t1 = datetime.utcnow()
                    else:
                        t1 = datetime.fromisoformat(str(zr["to"]).replace("Z", "").replace("+00:00", ""))
                    dev_downtime_min += (t1 - t0).total_seconds() / 60
                except Exception:
                    pass
            total_downtime_minutes += dev_downtime_min

            # Estimate lost energy
            avg_p = sum(x["p"] for x in powers) / len(powers) if powers else 0
            non_zero_p = [x["p"] for x in powers if x["p"] > 1.0]
            avg_running_p = sum(non_zero_p) / len(non_zero_p) if non_zero_p else 0
            estimated_lost_kwh = round(avg_running_p * (dev_downtime_min / 60), 1) if dev_downtime_min > 0 else 0
            total_energy_lost_kwh += estimated_lost_kwh

            dev_analysis = {
                "device_id": did,
                "name": dname,
                "type": "Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€" if dtype == "generator" else "Ð¨ÐŸÐ ",
                "data_points": len(hist),
                "avg_power_kw": round(avg_p, 1),
                "avg_running_power_kw": round(avg_running_p, 1),
                "max_power_kw": round(max(x["p"] for x in powers), 1) if powers else 0,
                "min_power_kw": round(min(x["p"] for x in powers), 1) if powers else 0,
                "energy_kwh": energy_delta,
                "zero_power_periods": len(zero_runs),
                "downtime_minutes": round(dev_downtime_min, 0),
                "estimated_lost_kwh": estimated_lost_kwh,
            }
            if rh_delta is not None:
                dev_analysis["run_hours_delta"] = rh_delta
            if zero_runs:
                dev_analysis["zero_power_details"] = zero_runs[:10]

            # Full-period metric ranges for generators
            if dtype == "generator":
                temps = [pt.get("coolant_temp") for pt in hist if pt.get("coolant_temp") is not None]
                oils = [pt.get("oil_pressure") for pt in hist if pt.get("oil_pressure") is not None]
                speeds = [pt.get("engine_speed") for pt in hist if pt.get("engine_speed") is not None]
                freqs = [pt.get("frequency") for pt in hist if pt.get("frequency") is not None]
                volts = [pt.get("gen_uab") for pt in hist if pt.get("gen_uab") is not None]

                if temps:
                    dev_analysis["coolant_temp_C"] = {"min": _rnd(min(temps)), "max": _rnd(max(temps)), "avg": _rnd(sum(temps)/len(temps))}
                if oils:
                    dev_analysis["oil_pressure_kPa"] = {"min": _rnd(min(oils)), "max": _rnd(max(oils)), "avg": _rnd(sum(oils)/len(oils))}
                if speeds:
                    dev_analysis["engine_speed_rpm"] = {"min": _rnd(min(speeds)), "max": _rnd(max(speeds)), "avg": _rnd(sum(speeds)/len(speeds))}
                if freqs:
                    dev_analysis["frequency_Hz"] = {"min": _rnd(min(freqs)), "max": _rnd(max(freqs)), "avg": _rnd(sum(freqs)/len(freqs))}
                if volts:
                    dev_analysis["voltage_V"] = {"min": _rnd(min(volts)), "max": _rnd(max(volts)), "avg": _rnd(sum(volts)/len(volts))}

            # Alarm count for this device
            dev_alarms = [a for a in report["alarms_timeline"] if a.get("device_id") == did]
            dev_analysis["alarm_count"] = len(dev_alarms)
            dev_analysis["active_alarm_count"] = sum(1 for a in dev_alarms if a.get("is_active"))

            # Journal events (state transitions) for this device
            _jbd = report.get("_journal_by_device", {})
            dev_journal = _jbd.get(did, [])
            if dev_journal:
                dev_analysis["state_transitions"] = dev_journal[:30]  # Last 30 transitions
                # Summarize key transitions for quick overview
                gs_transitions = [j for j in dev_journal if j.get("category") == "GEN_STATUS"]
                mode_transitions = [j for j in dev_journal if j.get("category") == "MODE_CHANGE"]
                mains_events = [j for j in dev_journal if j.get("category") == "MAINS"]
                sys_events = [j for j in dev_journal if j.get("category") == "SYSTEM"]
                dev_analysis["transition_summary"] = {
                    "gen_status_changes": len(gs_transitions),
                    "mode_changes": len(mode_transitions),
                    "mains_events": len(mains_events),
                    "system_events": len(sys_events),
                    "total_journal_events": len(dev_journal),
                }

            report["devices_analysis"].append(dev_analysis)

        # 4. Summary with plan vs actual
        total_alarms = len(report["alarms_timeline"])
        active_alarms = sum(1 for a in report["alarms_timeline"] if a.get("is_active"))
        shutdown_alarms = sum(1 for a in report["alarms_timeline"] if a.get("severity") == "shutdown")

        # Plan vs actual calculation
        gen_count = sum(1 for da in report["devices_analysis"] if da.get("type") == "Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€")
        nominal_kw = 160  # Each generator's nominal power
        plan_kwh = round(nominal_kw * gen_count * last_hours, 1) if gen_count > 0 else 0
        actual_kwh = sum(da.get("energy_kwh", 0) or 0 for da in report["devices_analysis"] if da.get("type") == "Ð³ÐµÐ½ÐµÑ€Ð°Ñ‚Ð¾Ñ€")
        utilization_pct = round(actual_kwh / plan_kwh * 100, 1) if plan_kwh > 0 else 0

        report["summary"] = {
            "total_alarms": total_alarms,
            "active_alarms_now": active_alarms,
            "shutdown_alarms": shutdown_alarms,
            "total_downtime_minutes": round(total_downtime_minutes, 0),
            "total_downtime_hours": round(total_downtime_minutes / 60, 1),
            "estimated_energy_lost_kwh": round(total_energy_lost_kwh, 1),
            "devices_analyzed": len(report["devices_analysis"]),
            "generators_count": gen_count,
            "nominal_power_per_gen_kw": nominal_kw,
            "plan_energy_kwh": plan_kwh,
            "actual_energy_kwh": round(actual_kwh, 1),
            "utilization_pct": utilization_pct,
            "underproduction_kwh": round(plan_kwh - actual_kwh, 1) if plan_kwh > actual_kwh else 0,
        }

        # Cleanup internal temp data
        report.pop("_journal_by_device", None)

    except Exception as e:
        logger.error("Error analyzing incident: %s", e, exc_info=True)
        report["error"] = str(e)

    return report


def _rnd(val, digits=1):
    """Round a value if it's a number, else return None."""
    if val is None:
        return None
    try:
        return round(float(val), digits)
    except (TypeError, ValueError):
        return None


async def _get_energy_delta(device_id: int, last_hours: int, is_generator: bool = True) -> dict:
    """Get energy_kwh and run_hours deltas using first/last points.

    Returns dict with energy_delta, rh_delta, actual_hours (or None).
    Tries shorter periods if no valid data at full range (old data may lack energy_kwh).
    """
    result = {"energy_delta": None, "rh_delta": None, "actual_hours": None}
    e_fields = "energy_kwh,run_hours" if is_generator else "energy_kwh"

    def _first_valid(pts, field):
        """Find first non-null positive value in a list of points."""
        if not isinstance(pts, list):
            return None
        for pt in pts:
            v = pt.get(field)
            if v is not None and v > 0:
                return v
        return None

    try:
        # Get latest point first
        last_pts = await _api_get(f"/api/history/metrics/{device_id}", {
            "last_minutes": 5, "fields": e_fields, "limit": 10,
        })
        rev_last = list(reversed(last_pts)) if isinstance(last_pts, list) else []
        e1 = _first_valid(rev_last, "energy_kwh")
        rh1 = _first_valid(rev_last, "run_hours") if is_generator else None

        if e1 is None:
            return result  # No energy data at all

        # Try progressively shorter periods to find first valid start point
        periods = sorted(set([last_hours] + [h for h in [120, 72, 48, 24] if h < last_hours]), reverse=True)
        e0 = None
        rh0 = None
        actual_h = last_hours
        for try_h in periods:
            first_pts = await _api_get(f"/api/history/metrics/{device_id}", {
                "last_hours": try_h, "fields": e_fields, "limit": 50,
            })
            e0 = _first_valid(first_pts, "energy_kwh")
            if is_generator:
                rh0 = _first_valid(first_pts, "run_hours")
            if e0 is not None:
                actual_h = try_h
                break

        if e0 is not None and e1 >= e0:
            result["energy_delta"] = round(e1 - e0, 1)
            result["actual_hours"] = actual_h
        if rh0 is not None and rh1 is not None and rh1 >= rh0:
            result["rh_delta"] = round(rh1 - rh0, 1)
    except Exception as e:
        logger.warning("Energy delta calc failed for device %d: %s", device_id, e)
    return result


async def _search_knowledge_base(query: str, category: str = None) -> dict:
    """Search knowledge base via internal API."""
    params = {"q": query, "limit": 5}
    if category:
        params["category"] = category
    try:
        results = await _api_get("/api/ai/knowledge/search", params)
        if isinstance(results, list) and results:
            return {
                "found": len(results),
                "results": [
                    {
                        "title": r.get("title", ""),
                        "content": r.get("content", "")[:1500],
                        "source": r.get("source_filename", ""),
                        "category": r.get("category", ""),
                    }
                    for r in results
                ],
            }
        return {"found": 0, "results": [], "hint": "Ð‘Ð°Ð·Ð° Ð·Ð½Ð°Ð½Ð¸Ð¹ Ð¿ÑƒÑÑ‚Ð° Ð¸Ð»Ð¸ Ð½ÐµÑ‚ ÑÐ¾Ð²Ð¿Ð°Ð´ÐµÐ½Ð¸Ð¹. ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ð´Ñ€ÑƒÐ³Ð¸Ðµ ÐºÐ»ÑŽÑ‡ÐµÐ²Ñ‹Ðµ ÑÐ»Ð¾Ð²Ð°."}
    except Exception as e:
        logger.warning("Knowledge base search error: %s", e)
        return {"found": 0, "error": str(e), "hint": "Ð‘Ð°Ð·Ð° Ð·Ð½Ð°Ð½Ð¸Ð¹ Ð½ÐµÐ´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð°."}


# ---------------------------------------------------------------------------
# Format tools for different LLM providers
# ---------------------------------------------------------------------------
def _tools_for_openai() -> list[dict]:
    """Format tools for OpenAI / Grok function calling."""
    return [
        {
            "type": "function",
            "function": {
                "name": t["name"],
                "description": t["description"],
                "parameters": t["parameters"],
            },
        }
        for t in SCADA_TOOLS
    ]


def _tools_for_claude() -> list[dict]:
    """Format tools for Claude (Anthropic) tool use."""
    return [
        {
            "name": t["name"],
            "description": t["description"],
            "input_schema": t["parameters"],
        }
        for t in SCADA_TOOLS
    ]


def _tools_for_gemini() -> list[dict]:
    """Format tools for Gemini function calling."""
    return [
        {
            "name": t["name"],
            "description": t["description"],
            "parameters": t["parameters"],
        }
        for t in SCADA_TOOLS
    ]


# ---------------------------------------------------------------------------
# SanekAssistant â€” main class
# ---------------------------------------------------------------------------
class SanekAssistant:
    """
    AI assistant for SCADA operators.

    Usage:
        assistant = SanekAssistant(provider="openai", api_key="sk-...", model="gpt-4o")
        response = await assistant.chat(messages, pending_action=None)
    """

    def __init__(self, provider: str, api_key: str, model: str = ""):
        self.provider = provider
        self.api_key = api_key
        self.model = model or {
            "openai": "gpt-4o",
            "claude": "claude-sonnet-4-20250514",
            "gemini": "gemini-2.5-flash",
            "grok": "grok-3-mini",
        }.get(provider, "gpt-4o")
        self.timeout = settings.AI_TIMEOUT

    async def chat(
        self,
        messages: list[dict],
        pending_action: Optional[dict] = None,
    ) -> dict:
        """
        Process a chat turn with tool calling.

        Args:
            messages: Conversation history [{role, content}]
            pending_action: If set, user is confirming/declining a previous action.

        Returns:
            {
                "message": str,          # Assistant's text reply
                "actions": [...]          # Executed tool calls
                "pending_action": {...}   # If dangerous command needs confirmation
            }
        """
        # Handle pending action confirmation
        if pending_action:
            last_msg = messages[-1].get("content", "").strip().lower() if messages else ""
            if last_msg in ("Ð´Ð°", "yes", "Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´Ð°ÑŽ", "Ð¾Ðº", "ok", "Ð´Ð°Ð²Ð°Ð¹"):
                # Execute the confirmed action
                tool_name = pending_action["tool"]
                tool_args = pending_action["args"]
                logger.info("Executing confirmed action: %s(%s)", tool_name, tool_args)
                result = await execute_tool(tool_name, tool_args)
                return {
                    "message": f"âœ… Ð’Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¾: {pending_action.get('description', tool_name)}\n\nÐ ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚: {json.dumps(result, ensure_ascii=False, indent=2)[:500]}",
                    "actions": [{"tool": tool_name, "args": tool_args, "result": result}],
                    "pending_action": None,
                }
            else:
                return {
                    "message": "âŒ Ð”ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ Ð¾Ñ‚Ð¼ÐµÐ½ÐµÐ½Ð¾.",
                    "actions": [],
                    "pending_action": None,
                }

        # Build messages with system prompt
        full_messages = [{"role": "system", "content": SANEK_SYSTEM_PROMPT}] + messages

        # Call LLM with tools
        if self.provider in ("openai", "grok"):
            return await self._chat_openai(full_messages)
        elif self.provider == "claude":
            return await self._chat_claude(full_messages)
        elif self.provider == "gemini":
            return await self._chat_gemini(full_messages)
        else:
            return {"message": f"ÐÐµÐ¸Ð·Ð²ÐµÑÑ‚Ð½Ñ‹Ð¹ Ð¿Ñ€Ð¾Ð²Ð°Ð¹Ð´ÐµÑ€: {self.provider}", "actions": [], "pending_action": None}

    # ------------------------------------------------------------------
    # OpenAI / Grok
    # ------------------------------------------------------------------
    async def _chat_openai(self, messages: list[dict]) -> dict:
        from openai import AsyncOpenAI

        base_url = "https://api.x.ai/v1" if self.provider == "grok" else None
        client = AsyncOpenAI(
            api_key=self.api_key,
            timeout=self.timeout,
            base_url=base_url,
        )

        tools = _tools_for_openai()
        actions = []

        # Allow up to 5 tool call rounds
        for _ in range(5):
            try:
                response = await client.chat.completions.create(
                    model=self.model,
                    messages=messages,
                    tools=tools,
                    temperature=0.3,
                )
            except Exception as e:
                logger.error("OpenAI/Grok error: %s", e)
                return {"message": _format_llm_error(self.provider, e), "actions": actions, "pending_action": None}

            choice = response.choices[0]

            # If tool calls requested
            if choice.message.tool_calls:
                messages.append(choice.message.model_dump())

                for tc in choice.message.tool_calls:
                    tool_name = tc.function.name
                    tool_args = json.loads(tc.function.arguments) if tc.function.arguments else {}

                    logger.info("Tool call: %s(%s)", tool_name, tool_args)

                    # Check if dangerous â€” return pending action
                    if tool_name in DANGEROUS_TOOLS:
                        pending = self._build_pending_action(tool_name, tool_args)
                        return {
                            "message": pending["description"],
                            "actions": actions,
                            "pending_action": pending,
                        }

                    # Execute safe tool
                    result = await execute_tool(tool_name, tool_args)
                    actions.append({"tool": tool_name, "args": tool_args, "result": result})

                    messages.append({
                        "role": "tool",
                        "tool_call_id": tc.id,
                        "content": json.dumps(result, ensure_ascii=False, default=str),
                    })

                continue  # Next round with tool results

            # No more tool calls â€” return final text
            text = choice.message.content or ""
            return {"message": text, "actions": actions, "pending_action": None}

        # Max rounds reached
        return {"message": "Ð”Ð¾ÑÑ‚Ð¸Ð³Ð½ÑƒÑ‚ Ð»Ð¸Ð¼Ð¸Ñ‚ Ð²Ñ‹Ð·Ð¾Ð²Ð¾Ð² Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð².", "actions": actions, "pending_action": None}

    # ------------------------------------------------------------------
    # Claude (Anthropic)
    # ------------------------------------------------------------------
    async def _chat_claude(self, messages: list[dict]) -> dict:
        tools = _tools_for_claude()
        actions = []

        # Separate system prompt from messages
        system_text = ""
        chat_msgs = []
        for m in messages:
            if m["role"] == "system":
                system_text += m["content"] + "\n"
            else:
                chat_msgs.append(m)

        for _ in range(5):
            try:
                async with httpx.AsyncClient(timeout=self.timeout) as http:
                    body = {
                        "model": self.model,
                        "max_tokens": 4096,
                        "system": system_text.strip(),
                        "messages": chat_msgs,
                        "tools": tools,
                        "temperature": 0.3,
                    }
                    resp = await http.post(
                        "https://api.anthropic.com/v1/messages",
                        headers={
                            "x-api-key": self.api_key,
                            "anthropic-version": "2023-06-01",
                            "content-type": "application/json",
                        },
                        json=body,
                    )
            except Exception as e:
                logger.error("Claude error: %s", e)
                return {"message": _format_llm_error("claude", e), "actions": actions, "pending_action": None}

            if resp.status_code != 200:
                try:
                    err = resp.json().get("error", {}).get("message", resp.text[:200])
                except Exception:
                    err = resp.text[:200]
                return {"message": _format_http_error("claude", resp.status_code, err), "actions": actions, "pending_action": None}

            data = resp.json()
            stop_reason = data.get("stop_reason", "")
            content_blocks = data.get("content", [])

            # Collect text and tool_use blocks
            text_parts = []
            tool_uses = []
            for block in content_blocks:
                if block["type"] == "text":
                    text_parts.append(block["text"])
                elif block["type"] == "tool_use":
                    tool_uses.append(block)

            if tool_uses:
                # Add assistant message with all content blocks
                chat_msgs.append({"role": "assistant", "content": content_blocks})

                tool_results = []
                for tu in tool_uses:
                    tool_name = tu["name"]
                    tool_args = tu.get("input", {})

                    logger.info("Claude tool call: %s(%s)", tool_name, tool_args)

                    # Check if dangerous
                    if tool_name in DANGEROUS_TOOLS:
                        pending = self._build_pending_action(tool_name, tool_args)
                        text = "\n".join(text_parts) if text_parts else ""
                        return {
                            "message": (text + "\n\n" + pending["description"]).strip(),
                            "actions": actions,
                            "pending_action": pending,
                        }

                    result = await execute_tool(tool_name, tool_args)
                    actions.append({"tool": tool_name, "args": tool_args, "result": result})

                    tool_results.append({
                        "type": "tool_result",
                        "tool_use_id": tu["id"],
                        "content": json.dumps(result, ensure_ascii=False, default=str),
                    })

                chat_msgs.append({"role": "user", "content": tool_results})
                continue

            # No tool calls â€” return text
            text = "\n".join(text_parts)
            return {"message": text, "actions": actions, "pending_action": None}

        return {"message": "Ð”Ð¾ÑÑ‚Ð¸Ð³Ð½ÑƒÑ‚ Ð»Ð¸Ð¼Ð¸Ñ‚ Ð²Ñ‹Ð·Ð¾Ð²Ð¾Ð² Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð².", "actions": actions, "pending_action": None}

    # ------------------------------------------------------------------
    # Gemini
    # ------------------------------------------------------------------
    async def _chat_gemini(self, messages: list[dict]) -> dict:
        tools = _tools_for_gemini()
        actions = []

        # Convert messages to Gemini format
        gemini_contents = []
        system_text = ""
        for m in messages:
            if m["role"] == "system":
                system_text += m["content"] + "\n"
            elif m["role"] == "user":
                gemini_contents.append({"role": "user", "parts": [{"text": m["content"]}]})
            elif m["role"] == "assistant":
                gemini_contents.append({"role": "model", "parts": [{"text": m.get("content", "")}]})

        # Prepend system as first user message if needed
        if system_text and gemini_contents:
            first = gemini_contents[0]
            if first["role"] == "user":
                first["parts"][0]["text"] = system_text.strip() + "\n\n" + first["parts"][0]["text"]

        url = (
            f"https://generativelanguage.googleapis.com/v1beta/models/"
            f"{self.model}:generateContent?key={self.api_key}"
        )

        for _ in range(5):
            try:
                async with httpx.AsyncClient(timeout=self.timeout) as http:
                    body = {
                        "contents": gemini_contents,
                        "tools": [{"function_declarations": tools}],
                        "generationConfig": {
                            "temperature": 0.3,
                            "maxOutputTokens": 4096,
                        },
                    }
                    resp = await http.post(url, json=body)
            except Exception as e:
                logger.error("Gemini error: %s", e)
                return {"message": _format_llm_error("gemini", e), "actions": actions, "pending_action": None}

            if resp.status_code != 200:
                try:
                    err = resp.json().get("error", {}).get("message", resp.text[:200])
                except Exception:
                    err = resp.text[:200]
                return {"message": _format_http_error("gemini", resp.status_code, err), "actions": actions, "pending_action": None}

            data = resp.json()
            candidate = data.get("candidates", [{}])[0]
            parts = candidate.get("content", {}).get("parts", [])

            text_parts = []
            function_calls = []
            for part in parts:
                if "text" in part:
                    text_parts.append(part["text"])
                if "functionCall" in part:
                    function_calls.append(part["functionCall"])

            if function_calls:
                # Add model response
                gemini_contents.append({"role": "model", "parts": parts})

                func_responses = []
                for fc in function_calls:
                    tool_name = fc["name"]
                    tool_args = fc.get("args", {})

                    logger.info("Gemini tool call: %s(%s)", tool_name, tool_args)

                    if tool_name in DANGEROUS_TOOLS:
                        pending = self._build_pending_action(tool_name, tool_args)
                        text = "\n".join(text_parts) if text_parts else ""
                        return {
                            "message": (text + "\n\n" + pending["description"]).strip(),
                            "actions": actions,
                            "pending_action": pending,
                        }

                    result = await execute_tool(tool_name, tool_args)
                    actions.append({"tool": tool_name, "args": tool_args, "result": result})

                    func_responses.append({
                        "functionResponse": {
                            "name": tool_name,
                            "response": result,
                        }
                    })

                gemini_contents.append({"role": "user", "parts": func_responses})
                continue

            text = "\n".join(text_parts)
            return {"message": text, "actions": actions, "pending_action": None}

        return {"message": "Ð”Ð¾ÑÑ‚Ð¸Ð³Ð½ÑƒÑ‚ Ð»Ð¸Ð¼Ð¸Ñ‚ Ð²Ñ‹Ð·Ð¾Ð²Ð¾Ð² Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð².", "actions": actions, "pending_action": None}

    # ------------------------------------------------------------------
    # Helpers
    # ------------------------------------------------------------------
    def _build_pending_action(self, tool_name: str, tool_args: dict) -> dict:
        """Build a pending action that requires operator confirmation."""
        if tool_name == "send_command":
            cmd = tool_args.get("command", "")
            dev_id = tool_args.get("device_id", "?")
            label = COMMAND_LABELS.get(cmd, cmd)
            desc = f"âš  {label} ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð° ID={dev_id}?\n\nÐžÑ‚Ð²ÐµÑ‚ÑŒÑ‚Ðµ Â«Ð”Ð°Â» Ð´Ð»Ñ Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ñ Ð¸Ð»Ð¸ Â«ÐÐµÑ‚Â» Ð´Ð»Ñ Ð¾Ñ‚Ð¼ÐµÐ½Ñ‹."
        elif tool_name == "set_power_limit":
            dev_id = tool_args.get("device_id", "?")
            p = tool_args.get("p_percent", "â€”")
            q = tool_args.get("q_percent", "â€”")
            desc = f"âš  Ð£ÑÑ‚Ð°Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ Ð¾Ð³Ñ€Ð°Ð½Ð¸Ñ‡ÐµÐ½Ð¸Ðµ Ð¼Ð¾Ñ‰Ð½Ð¾ÑÑ‚Ð¸ Ð´Ð»Ñ ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð° ID={dev_id}: P={p}%, Q={q}%?\n\nÐžÑ‚Ð²ÐµÑ‚ÑŒÑ‚Ðµ Â«Ð”Ð°Â» Ð´Ð»Ñ Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ñ Ð¸Ð»Ð¸ Â«ÐÐµÑ‚Â» Ð´Ð»Ñ Ð¾Ñ‚Ð¼ÐµÐ½Ñ‹."
        else:
            desc = f"âš  Ð’Ñ‹Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÑŒ {tool_name}?"

        return {
            "tool": tool_name,
            "args": tool_args,
            "description": desc,
        }
